"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generatePermittedFileTypes),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n\n\nvar version$1 = \"6.7.0\";\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */ async function uploadPartWithProgress(opts, retryCount = 0) {\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.onload = async ()=>{\n            if (xhr.status >= 200 && xhr.status < 300) {\n                const etag = xhr.getResponseHeader(\"Etag\");\n                etag ? resolve(etag) : reject(\"NO ETAG\");\n            } else if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 1000;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        let lastProgress = 0;\n        xhr.onerror = async ()=>{\n            lastProgress = 0;\n            if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 100;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        xhr.upload.onprogress = (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        };\n        xhr.send(opts.chunk);\n    });\n}\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */ const createUTReporter = (cfg)=>{\n    return async (type, payload)=>{\n        const url = createAPIRequestUrl({\n            url: cfg.url,\n            slug: cfg.endpoint,\n            actionType: type\n        });\n        let customHeaders = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n        if (customHeaders instanceof Promise) customHeaders = await customHeaders;\n        const response = await cfg.fetch(url, {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-package\": cfg.package,\n                \"x-uploadthing-version\": version$1,\n                ...customHeaders\n            }\n        });\n        switch(type){\n            case \"failure\":\n                {\n                    // why isn't this narrowed automatically?\n                    const p = payload;\n                    const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n                    if (parsed?.message) {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: parsed.code,\n                            message: parsed.message\n                        });\n                    } else {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: `Failed to upload file ${p.fileName} to S3`,\n                            cause: p.s3Error\n                        });\n                    }\n                }\n        }\n        if (!response.ok) {\n            const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(response);\n            throw error;\n        }\n        const jsonOrError = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(response);\n        if (jsonOrError instanceof Error) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: jsonOrError.message,\n                cause: response\n            });\n        }\n        return jsonOrError;\n    };\n};\n// Don't want to ship our logger to the client, keep size down\nconst version = version$1;\nconst uploadFilesInternal = async (endpoint, opts)=>{\n    // Fine to use global fetch in browser\n    const fetch = globalThis.fetch.bind(globalThis);\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        url: opts.url,\n        package: opts.package,\n        fetch,\n        headers: opts.headers\n    });\n    // Get presigned URL for S3 upload\n    const s3ConnectionRes = await reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    });\n    if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"No URL. How did you even get here?\",\n            cause: s3ConnectionRes\n        });\n    }\n    const fileUploadPromises = s3ConnectionRes.map(async (presigned)=>{\n        const file = opts.files.find((f)=>f.name === presigned.fileName);\n        if (!file) {\n            console.error(\"No file found for presigned URL\", presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: \"No file found for presigned URL\",\n                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n            });\n        }\n        opts.onUploadBegin?.({\n            file: file.name\n        });\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n            // wait a bit as it's unsreasonable to expect the server to be done by now\n            await new Promise((r)=>setTimeout(r, 750));\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n        }\n        let serverData = null;\n        if (!opts.skipPolling) {\n            serverData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.withExponentialBackoff)(async ()=>{\n                const res = await fetch(presigned.pollingUrl, {\n                    headers: {\n                        authorization: presigned.pollingJwt\n                    }\n                }).then((r)=>r.json());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return res.status === \"done\" ? res.callbackData : undefined;\n            });\n        }\n        return {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            key: presigned.key,\n            url: \"https://utfs.io/f/\" + presigned.key,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            serverData: serverData,\n            customId: presigned.customId\n        };\n    });\n    return Promise.all(fileUploadPromises);\n};\nconst genUploader = (initOpts)=>{\n    return (endpoint, opts)=>uploadFilesInternal(endpoint, {\n            ...opts,\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(initOpts?.url),\n            package: initOpts.package\n        });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    let etags;\n    let uploadedBytes = 0;\n    try {\n        etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            const etag = await uploadPartWithProgress({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                maxRetries: 10,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            });\n            return {\n                tag: etag,\n                partNumber: index + 1\n            };\n        }));\n    } catch (error) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    }\n    // Tell the server that the upload is complete\n    await opts.reportEventToUT(\"multipart-complete\", {\n        uploadId: presigned.uploadId,\n        fileKey: presigned.key,\n        etags\n    }).catch((res)=>{\n        console.log(\"Failed to alert UT of upload completion\");\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to alert UT of upload completion\",\n            cause: res\n        });\n    });\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const response = await new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.onprogress = (p)=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: p.loaded / p.total * 100\n            });\n        };\n        xhr.onload = ()=>resolve({\n                status: xhr.status\n            });\n        xhr.onerror = (e)=>reject(e);\n        xhr.send(formData);\n    }).catch(async (error)=>{\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    });\n    if (response.status > 299 || response.status < 200) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name\n        });\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzSTtBQUNwQjtBQUVsSCxJQUFJUSxZQUFZO0FBRWhCLE1BQU1DLHdCQUF3QixDQUFDQztJQUMzQixNQUFNQyxZQUFZRCxTQUFTRSxLQUFLLENBQUM7SUFDakMsTUFBTUMsZUFBZUgsU0FBU0UsS0FBSyxDQUFDO0lBQ3BDLE1BQU1FLE9BQU9ILFdBQVcsQ0FBQyxFQUFFO0lBQzNCLE1BQU1JLFVBQVVGLGNBQWMsQ0FBQyxFQUFFO0lBQ2pDLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLE9BQU87SUFDOUIsT0FBTztRQUNIRCxNQUFNRSx1QkFBdUIsQ0FBQ0YsS0FBSyxJQUFJRztRQUN2Q0Y7SUFDSjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQUcsTUFBTUUscUJBQXFCO0FBQy9CLE1BQU1ELDBCQUEwQjtJQUM1QkUsY0FBYztJQUNkQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxxQ0FBcUM7SUFDckNDLGVBQWU7SUFDZkMsaUJBQWlCO0lBQ2pCQywwQkFBMEI7QUFDOUI7QUFFQTs7O0NBR0MsR0FBRyxlQUFlQyx1QkFBdUJDLElBQUksRUFBRUMsYUFBYSxDQUFDO0lBQzFELE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUN6QixNQUFNQyxNQUFNLElBQUlDO1FBQ2hCRCxJQUFJRSxJQUFJLENBQUMsT0FBT1AsS0FBS1EsR0FBRyxFQUFFO1FBQzFCSCxJQUFJSSxnQkFBZ0IsQ0FBQyxnQkFBZ0JULEtBQUtVLFFBQVE7UUFDbERMLElBQUlJLGdCQUFnQixDQUFDLHVCQUF1QnBDLHVFQUFrQkEsQ0FBQzJCLEtBQUszQixrQkFBa0IsRUFBRTJCLEtBQUtXLFFBQVE7UUFDckdOLElBQUlPLE1BQU0sR0FBRztZQUNULElBQUlQLElBQUlRLE1BQU0sSUFBSSxPQUFPUixJQUFJUSxNQUFNLEdBQUcsS0FBSztn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QyxRQUFRaEQsT0FBTyw2QkFBNkI7SUFDNUQsTUFBTWpDLFdBQVcsTUFBTSxJQUFJL0MsUUFBUSxDQUFDQyxTQUFTQztRQUN6QyxNQUFNQyxNQUFNLElBQUlDO1FBQ2hCRCxJQUFJRSxJQUFJLENBQUMsUUFBUTBFLFVBQVV6RSxHQUFHO1FBQzlCSCxJQUFJSSxnQkFBZ0IsQ0FBQyxVQUFVO1FBQy9CSixJQUFJbUIsTUFBTSxDQUFDQyxVQUFVLEdBQUcsQ0FBQytCO1lBQ3JCeEQsS0FBS2tILGdCQUFnQixHQUFHO2dCQUNwQmhDLE1BQU1BLEtBQUtOLElBQUk7Z0JBQ2Z1QyxVQUFVM0QsRUFBRTVCLE1BQU0sR0FBRzRCLEVBQUUyRSxLQUFLLEdBQUc7WUFDbkM7UUFDSjtRQUNBOUgsSUFBSU8sTUFBTSxHQUFHLElBQUlULFFBQVE7Z0JBQ2pCVSxRQUFRUixJQUFJUSxNQUFNO1lBQ3RCO1FBQ0pSLElBQUlrQixPQUFPLEdBQUcsQ0FBQ0csSUFBSXRCLE9BQU9zQjtRQUMxQnJCLElBQUl5QixJQUFJLENBQUM0RjtJQUNiLEdBQUdGLEtBQUssQ0FBQyxPQUFPM0Q7UUFDWixNQUFNN0QsS0FBS3FFLGVBQWUsQ0FBQyxXQUFXO1lBQ2xDaUQsU0FBU3JDLFVBQVVrQixHQUFHO1lBQ3RCb0IsVUFBVTtZQUNWNUcsVUFBVXVFLEtBQUtOLElBQUk7WUFDbkJsQixTQUFTRyxNQUFNcEIsUUFBUTtRQUMzQjtRQUNBLE1BQU0sZUFBZSxrQ0FBa0M7SUFDM0Q7SUFDQSxJQUFJUSxTQUFTcEMsTUFBTSxHQUFHLE9BQU9vQyxTQUFTcEMsTUFBTSxHQUFHLEtBQUs7UUFDaEQsTUFBTWIsS0FBS3FFLGVBQWUsQ0FBQyxXQUFXO1lBQ2xDaUQsU0FBU3JDLFVBQVVrQixHQUFHO1lBQ3RCb0IsVUFBVTtZQUNWNUcsVUFBVXVFLEtBQUtOLElBQUk7UUFDdkI7SUFDSjtBQUNKO0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRseS8uL25vZGVfbW9kdWxlcy91cGxvYWR0aGluZy9jbGllbnQvaW5kZXguanM/NmY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb250ZW50RGlzcG9zaXRpb24sIFVwbG9hZFRoaW5nRXJyb3IsIHNhZmVQYXJzZUpTT04sIHJlc29sdmVNYXliZVVybEFyZywgd2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuZXhwb3J0IHsgZ2VuZXJhdGVDbGllbnREcm9wem9uZUFjY2VwdCwgZ2VuZXJhdGVNaW1lVHlwZXMsIGdlbmVyYXRlUGVybWl0dGVkRmlsZVR5cGVzIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjYuNy4wXCI7XG5cbmNvbnN0IG1heWJlUGFyc2VSZXNwb25zZVhNTCA9IChtYXliZVhtbCk9PntcbiAgICBjb25zdCBjb2RlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPENvZGU+KC4qPyk8XFwvQ29kZT4vcyk7XG4gICAgY29uc3QgbWVzc2FnZU1hdGNoID0gbWF5YmVYbWwubWF0Y2goLzxNZXNzYWdlPiguKj8pPFxcL01lc3NhZ2U+L3MpO1xuICAgIGNvbnN0IGNvZGUgPSBjb2RlTWF0Y2g/LlsxXTtcbiAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZU1hdGNoPy5bMV07XG4gICAgaWYgKCFjb2RlIHx8ICFtZXNzYWdlKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZVtjb2RlXSA/PyBERUZBVUxUX0VSUk9SX0NPREUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICB9O1xufTtcbi8qKlxuICogTWFwIFMzIGVycm9yIGNvZGVzIHRvIFVwbG9hZFRoaW5nIGVycm9yIGNvZGVzXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgUzMgZXJyb3IgY29kZXMsIGJhc2VkIG9uIHdoYXQgc2VlbWVkIG1vc3QgbGlrZWx5IHRvXG4gKiBvY2N1ciBpbiB1cGxvYWR0aGluZy4gRm9yIGEgZnVsbCBsaXN0IG9mIFMzIGVycm9yIGNvZGVzLCBzZWU6XG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L0FQSS9FcnJvclJlc3BvbnNlcy5odG1sXG4gKi8gY29uc3QgREVGQVVMVF9FUlJPUl9DT0RFID0gXCJVUExPQURfRkFJTEVEXCI7XG5jb25zdCBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSA9IHtcbiAgICBBY2Nlc3NEZW5pZWQ6IFwiRk9SQklEREVOXCIsXG4gICAgRW50aXR5VG9vU21hbGw6IFwiVE9PX1NNQUxMXCIsXG4gICAgRW50aXR5VG9vTGFyZ2U6IFwiVE9PX0xBUkdFXCIsXG4gICAgRXhwaXJlZFRva2VuOiBcIkZPUkJJRERFTlwiLFxuICAgIEluY29ycmVjdE51bWJlck9mRmlsZXNJblBvc3RSZXF1ZXN0OiBcIlRPT19NQU5ZX0ZJTEVTXCIsXG4gICAgSW50ZXJuYWxFcnJvcjogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICBLZXlUb29Mb25nRXJyb3I6IFwiS0VZX1RPT19MT05HXCIsXG4gICAgTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkOiBcIlRPT19MQVJHRVwiXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgY2xpZW50IHVwbG9hZHMgd2hlcmUgcHJvZ3Jlc3MgaXMgbmVlZGVkLlxuICogVXNlcyBYTUxIdHRwUmVxdWVzdC5cbiAqLyBhc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKG9wdHMsIHJldHJ5Q291bnQgPSAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBVVFwiLCBvcHRzLnVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIG9wdHMuZmlsZVR5cGUpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiwgY29udGVudERpc3Bvc2l0aW9uKG9wdHMuY29udGVudERpc3Bvc2l0aW9uLCBvcHRzLmZpbGVOYW1lKSk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldGFnID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiRXRhZ1wiKTtcbiAgICAgICAgICAgICAgICBldGFnID8gcmVzb2x2ZShldGFnKSA6IHJlamVjdChcIk5PIEVUQUdcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJldHJ5Q291bnQgPCBvcHRzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBkZWxheSBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYgY2FuIGJlIHVzZWQpXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnBvdygyLCByZXRyeUNvdW50KSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcyk9PnNldFRpbWVvdXQocmVzLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCArIDEpOyAvLyBSZXRyeSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJNYXggcmV0cmllcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhc3RQcm9ncmVzcyA9IDA7XG4gICAgICAgIHhoci5vbmVycm9yID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGxhc3RQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBpZiAocmV0cnlDb3VudCA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZiBjYW4gYmUgdXNlZClcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogMTAwO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpPT5zZXRUaW1lb3V0KHJlcywgZGVsYXkpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKG9wdHMsIHJldHJ5Q291bnQgKyAxKTsgLy8gUmV0cnkgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiTWF4IHJldHJpZXMgZXhjZWVkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBlLmxvYWRlZCAtIGxhc3RQcm9ncmVzcztcbiAgICAgICAgICAgIGxhc3RQcm9ncmVzcyArPSBkZWx0YTtcbiAgICAgICAgICAgIG9wdHMub25Qcm9ncmVzcyhkZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG9wdHMuY2h1bmspO1xuICAgIH0pO1xufVxuXG5jb25zdCBjcmVhdGVBUElSZXF1ZXN0VXJsID0gKGNvbmZpZyk9PntcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNvbmZpZy51cmwpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuc2VhcmNoKTtcbiAgICBxdWVyeVBhcmFtcy5zZXQoXCJhY3Rpb25UeXBlXCIsIGNvbmZpZy5hY3Rpb25UeXBlKTtcbiAgICBxdWVyeVBhcmFtcy5zZXQoXCJzbHVnXCIsIGNvbmZpZy5zbHVnKTtcbiAgICB1cmwuc2VhcmNoID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdXJsO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIFwiY2xpZW50XCIgZm9yIHJlcG9ydGluZyBldmVudHMgdG8gdGhlIFVwbG9hZFRoaW5nIHNlcnZlciB2aWEgdGhlIHVzZXIncyBBUEkgZW5kcG9pbnQuXG4gKiBFdmVudHMgYXJlIGhhbmRsZWQgaW4gXCIuL2hhbmRsZXIudHMgc3RhcnRpbmcgYXQgTDIwMFwiXG4gKi8gY29uc3QgY3JlYXRlVVRSZXBvcnRlciA9IChjZmcpPT57XG4gICAgcmV0dXJuIGFzeW5jICh0eXBlLCBwYXlsb2FkKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBjcmVhdGVBUElSZXF1ZXN0VXJsKHtcbiAgICAgICAgICAgIHVybDogY2ZnLnVybCxcbiAgICAgICAgICAgIHNsdWc6IGNmZy5lbmRwb2ludCxcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjdXN0b21IZWFkZXJzID0gdHlwZW9mIGNmZy5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyBjZmcuaGVhZGVycygpIDogY2ZnLmhlYWRlcnM7XG4gICAgICAgIGlmIChjdXN0b21IZWFkZXJzIGluc3RhbmNlb2YgUHJvbWlzZSkgY3VzdG9tSGVhZGVycyA9IGF3YWl0IGN1c3RvbUhlYWRlcnM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZnLmZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1wYWNrYWdlXCI6IGNmZy5wYWNrYWdlLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24kMSxcbiAgICAgICAgICAgICAgICAuLi5jdXN0b21IZWFkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2h5IGlzbid0IHRoaXMgbmFycm93ZWQgYXV0b21hdGljYWxseT9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG1heWJlUGFyc2VSZXNwb25zZVhNTChwLnMzRXJyb3IgPz8gXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQ/Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBwYXJzZWQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZWQubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byB1cGxvYWQgZmlsZSAke3AuZmlsZU5hbWV9IHRvIFMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogcC5zM0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IFVwbG9hZFRoaW5nRXJyb3IuZnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb25PckVycm9yID0gYXdhaXQgc2FmZVBhcnNlSlNPTihyZXNwb25zZSk7XG4gICAgICAgIGlmIChqc29uT3JFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGpzb25PckVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHJlc3BvbnNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbk9yRXJyb3I7XG4gICAgfTtcbn07XG5cbi8vIERvbid0IHdhbnQgdG8gc2hpcCBvdXIgbG9nZ2VyIHRvIHRoZSBjbGllbnQsIGtlZXAgc2l6ZSBkb3duXG5jb25zdCB2ZXJzaW9uID0gdmVyc2lvbiQxO1xuY29uc3QgdXBsb2FkRmlsZXNJbnRlcm5hbCA9IGFzeW5jIChlbmRwb2ludCwgb3B0cyk9PntcbiAgICAvLyBGaW5lIHRvIHVzZSBnbG9iYWwgZmV0Y2ggaW4gYnJvd3NlclxuICAgIGNvbnN0IGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgIGNvbnN0IHJlcG9ydEV2ZW50VG9VVCA9IGNyZWF0ZVVUUmVwb3J0ZXIoe1xuICAgICAgICBlbmRwb2ludDogU3RyaW5nKGVuZHBvaW50KSxcbiAgICAgICAgdXJsOiBvcHRzLnVybCxcbiAgICAgICAgcGFja2FnZTogb3B0cy5wYWNrYWdlLFxuICAgICAgICBmZXRjaCxcbiAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgfSk7XG4gICAgLy8gR2V0IHByZXNpZ25lZCBVUkwgZm9yIFMzIHVwbG9hZFxuICAgIGNvbnN0IHMzQ29ubmVjdGlvblJlcyA9IGF3YWl0IHJlcG9ydEV2ZW50VG9VVChcInVwbG9hZFwiLCB7XG4gICAgICAgIGlucHV0OiBcImlucHV0XCIgaW4gb3B0cyA/IG9wdHMuaW5wdXQgOiBudWxsLFxuICAgICAgICBmaWxlczogb3B0cy5maWxlcy5tYXAoKGYpPT4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IGYubmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmLnNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogZi50eXBlXG4gICAgICAgICAgICB9KSlcbiAgICB9KTtcbiAgICBpZiAoIXMzQ29ubmVjdGlvblJlcyB8fCAhQXJyYXkuaXNBcnJheShzM0Nvbm5lY3Rpb25SZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gVVJMLiBIb3cgZGlkIHlvdSBldmVuIGdldCBoZXJlP1wiLFxuICAgICAgICAgICAgY2F1c2U6IHMzQ29ubmVjdGlvblJlc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZmlsZVVwbG9hZFByb21pc2VzID0gczNDb25uZWN0aW9uUmVzLm1hcChhc3luYyAocHJlc2lnbmVkKT0+e1xuICAgICAgICBjb25zdCBmaWxlID0gb3B0cy5maWxlcy5maW5kKChmKT0+Zi5uYW1lID09PSBwcmVzaWduZWQuZmlsZU5hbWUpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsIHByZXNpZ25lZCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJOT1RfRk9VTkRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIGZpbGUgZm91bmQgZm9yIHByZXNpZ25lZCBVUkxcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogYEV4cGVjdGVkIGZpbGUgd2l0aCBuYW1lICR7cHJlc2lnbmVkLmZpbGVOYW1lfSBidXQgZ290ICcke29wdHMuZmlsZXMuam9pbihcIixcIil9J2BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMub25VcGxvYWRCZWdpbj8uKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFwidXJsc1wiIGluIHByZXNpZ25lZCkge1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwge1xuICAgICAgICAgICAgICAgIHJlcG9ydEV2ZW50VG9VVCxcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdhaXQgYSBiaXQgYXMgaXQncyB1bnNyZWFzb25hYmxlIHRvIGV4cGVjdCB0aGUgc2VydmVyIHRvIGJlIGRvbmUgYnkgbm93XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocik9PnNldFRpbWVvdXQociwgNzUwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRQcmVzaWduZWRQb3N0KGZpbGUsIHByZXNpZ25lZCwge1xuICAgICAgICAgICAgICAgIHJlcG9ydEV2ZW50VG9VVCxcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VydmVyRGF0YSA9IG51bGw7XG4gICAgICAgIGlmICghb3B0cy5za2lwUG9sbGluZykge1xuICAgICAgICAgICAgc2VydmVyRGF0YSA9IGF3YWl0IHdpdGhFeHBvbmVudGlhbEJhY2tvZmYoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChwcmVzaWduZWQucG9sbGluZ1VybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBwcmVzaWduZWQucG9sbGluZ0p3dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbigocik9PnIuanNvbigpKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyA9PT0gXCJkb25lXCIgPyByZXMuY2FsbGJhY2tEYXRhIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIGtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVybDogXCJodHRwczovL3V0ZnMuaW8vZi9cIiArIHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBzZXJ2ZXJEYXRhOiBzZXJ2ZXJEYXRhLFxuICAgICAgICAgICAgY3VzdG9tSWQ6IHByZXNpZ25lZC5jdXN0b21JZFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlVXBsb2FkUHJvbWlzZXMpO1xufTtcbmNvbnN0IGdlblVwbG9hZGVyID0gKGluaXRPcHRzKT0+e1xuICAgIHJldHVybiAoZW5kcG9pbnQsIG9wdHMpPT4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB1cGxvYWRGaWxlc0ludGVybmFsKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgdXJsOiByZXNvbHZlTWF5YmVVcmxBcmcoaW5pdE9wdHM/LnVybCksXG4gICAgICAgICAgICBwYWNrYWdlOiBpbml0T3B0cy5wYWNrYWdlXG4gICAgICAgIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZE11bHRpcGFydChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBsZXQgZXRhZ3M7XG4gICAgbGV0IHVwbG9hZGVkQnl0ZXMgPSAwO1xuICAgIHRyeSB7XG4gICAgICAgIGV0YWdzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJlc2lnbmVkLnVybHMubWFwKGFzeW5jICh1cmwsIGluZGV4KT0+e1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcHJlc2lnbmVkLmNodW5rU2l6ZSAqIGluZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgcHJlc2lnbmVkLmNodW5rU2l6ZSwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCBldGFnID0gYXdhaXQgdXBsb2FkUGFydFdpdGhQcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IHByZXNpZ25lZC5jb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZmlsZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IDEwLFxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IChkZWx0YSk9PntcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkZWRCeXRlcyArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IHVwbG9hZGVkQnl0ZXMgLyBmaWxlLnNpemUgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IGV0YWcsXG4gICAgICAgICAgICAgICAgcGFydE51bWJlcjogaW5kZXggKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHMzRXJyb3I6IGVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IFwidW5yZWFjaGFibGVcIjsgLy8gZmFpbHVyZSBldmVudCB3aWxsIHRocm93IGZvciB1c1xuICAgIH1cbiAgICAvLyBUZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgdXBsb2FkIGlzIGNvbXBsZXRlXG4gICAgYXdhaXQgb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJtdWx0aXBhcnQtY29tcGxldGVcIiwge1xuICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICBldGFnc1xuICAgIH0pLmNhdGNoKChyZXMpPT57XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCIpO1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCIsXG4gICAgICAgICAgICBjYXVzZTogcmVzXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIE9iamVjdC5lbnRyaWVzKHByZXNpZ25lZC5maWVsZHMpLmZvckVhY2goKFtrLCB2XSk9PmZvcm1EYXRhLmFwcGVuZChrLCB2KSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTsgLy8gRmlsZSBkYXRhICoqTVVTVCBHTyBMQVNUKipcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgcHJlc2lnbmVkLnVybCk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAocCk9PntcbiAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHAubG9hZGVkIC8gcC50b3RhbCAqIDEwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmxvYWQgPSAoKT0+cmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSAoZSk9PnJlamVjdChlKTtcbiAgICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgIH0pLmNhdGNoKGFzeW5jIChlcnJvcik9PntcbiAgICAgICAgYXdhaXQgb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1cGxvYWRJZDogbnVsbCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBzM0Vycm9yOiBlcnJvci50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBcInVucmVhY2hhYmxlXCI7IC8vIGZhaWx1cmUgZXZlbnQgd2lsbCB0aHJvdyBmb3IgdXNcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID4gMjk5IHx8IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCkge1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBudWxsLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGdlblVwbG9hZGVyLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsiY29udGVudERpc3Bvc2l0aW9uIiwiVXBsb2FkVGhpbmdFcnJvciIsInNhZmVQYXJzZUpTT04iLCJyZXNvbHZlTWF5YmVVcmxBcmciLCJ3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiZ2VuZXJhdGVDbGllbnREcm9wem9uZUFjY2VwdCIsImdlbmVyYXRlTWltZVR5cGVzIiwiZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMiLCJ2ZXJzaW9uJDEiLCJtYXliZVBhcnNlUmVzcG9uc2VYTUwiLCJtYXliZVhtbCIsImNvZGVNYXRjaCIsIm1hdGNoIiwibWVzc2FnZU1hdGNoIiwiY29kZSIsIm1lc3NhZ2UiLCJzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSIsIkRFRkFVTFRfRVJST1JfQ09ERSIsIkFjY2Vzc0RlbmllZCIsIkVudGl0eVRvb1NtYWxsIiwiRW50aXR5VG9vTGFyZ2UiLCJFeHBpcmVkVG9rZW4iLCJJbmNvcnJlY3ROdW1iZXJPZkZpbGVzSW5Qb3N0UmVxdWVzdCIsIkludGVybmFsRXJyb3IiLCJLZXlUb29Mb25nRXJyb3IiLCJNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQiLCJ1cGxvYWRQYXJ0V2l0aFByb2dyZXNzIiwib3B0cyIsInJldHJ5Q291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInVybCIsInNldFJlcXVlc3RIZWFkZXIiLCJmaWxlVHlwZSIsImZpbGVOYW1lIiwib25sb2FkIiwic3RhdHVzIiwiZXRhZyIsImdldFJlc3BvbnNlSGVhZGVyIiwibWF4UmV0cmllcyIsImRlbGF5IiwiTWF0aCIsInBvdyIsInJlcyIsInNldFRpbWVvdXQiLCJsYXN0UHJvZ3Jlc3MiLCJvbmVycm9yIiwidXBsb2FkIiwib25wcm9ncmVzcyIsImUiLCJkZWx0YSIsImxvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJzZW5kIiwiY2h1bmsiLCJjcmVhdGVBUElSZXF1ZXN0VXJsIiwiY29uZmlnIiwiVVJMIiwicXVlcnlQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJzZXQiLCJhY3Rpb25UeXBlIiwic2x1ZyIsInRvU3RyaW5nIiwiY3JlYXRlVVRSZXBvcnRlciIsImNmZyIsInR5cGUiLCJwYXlsb2FkIiwiZW5kcG9pbnQiLCJjdXN0b21IZWFkZXJzIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBhY2thZ2UiLCJwIiwicGFyc2VkIiwiczNFcnJvciIsImNhdXNlIiwib2siLCJlcnJvciIsImZyb21SZXNwb25zZSIsImpzb25PckVycm9yIiwiRXJyb3IiLCJ2ZXJzaW9uIiwidXBsb2FkRmlsZXNJbnRlcm5hbCIsImdsb2JhbFRoaXMiLCJiaW5kIiwicmVwb3J0RXZlbnRUb1VUIiwiU3RyaW5nIiwiczNDb25uZWN0aW9uUmVzIiwiaW5wdXQiLCJmaWxlcyIsIm1hcCIsImYiLCJuYW1lIiwic2l6ZSIsIkFycmF5IiwiaXNBcnJheSIsImZpbGVVcGxvYWRQcm9taXNlcyIsInByZXNpZ25lZCIsImZpbGUiLCJmaW5kIiwiY29uc29sZSIsImpvaW4iLCJvblVwbG9hZEJlZ2luIiwidXBsb2FkTXVsdGlwYXJ0IiwiciIsInVwbG9hZFByZXNpZ25lZFBvc3QiLCJzZXJ2ZXJEYXRhIiwic2tpcFBvbGxpbmciLCJwb2xsaW5nVXJsIiwiYXV0aG9yaXphdGlvbiIsInBvbGxpbmdKd3QiLCJ0aGVuIiwianNvbiIsImNhbGxiYWNrRGF0YSIsInVuZGVmaW5lZCIsImtleSIsImN1c3RvbUlkIiwiYWxsIiwiZ2VuVXBsb2FkZXIiLCJpbml0T3B0cyIsImV0YWdzIiwidXBsb2FkZWRCeXRlcyIsInVybHMiLCJpbmRleCIsIm9mZnNldCIsImNodW5rU2l6ZSIsImVuZCIsIm1pbiIsInNsaWNlIiwicGVyY2VudCIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInRhZyIsInBhcnROdW1iZXIiLCJmaWxlS2V5IiwidXBsb2FkSWQiLCJjYXRjaCIsImxvZyIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmllbGRzIiwiZm9yRWFjaCIsImsiLCJ2IiwiYXBwZW5kIiwidG90YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/uploadthing/internal/types.js":
/*!****************************************************!*\
  !*** ./node_modules/uploadthing/internal/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UTFiles: () => (/* binding */ UTFiles),\n/* harmony export */   VALID_ACTION_TYPES: () => (/* binding */ VALID_ACTION_TYPES)\n/* harmony export */ });\n/**\n * Marker used to append a `customId` to the incoming file data in `.middleware()`\n * @example\n * ```ts\n * .middleware((opts) => {\n *   return {\n *     [UTFiles]: opts.files.map((file) => ({\n *       ...file,\n *       customId: generateId(),\n *     }))\n *   };\n * })\n * ```\n */ const UTFiles = Symbol(\"uploadthing-custom-id-symbol\");\n/**\n * Valid options for the `?actionType` query param\n */ const VALID_ACTION_TYPES = [\n    \"upload\",\n    \"failure\",\n    \"multipart-complete\"\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQUcsTUFBTUEsVUFBVUMsT0FBTztBQUMzQjs7Q0FFQyxHQUFHLE1BQU1DLHFCQUFxQjtJQUMzQjtJQUNBO0lBQ0E7Q0FDSDtBQUVzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50bHkvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMuanM/ODY3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1hcmtlciB1c2VkIHRvIGFwcGVuZCBhIGBjdXN0b21JZGAgdG8gdGhlIGluY29taW5nIGZpbGUgZGF0YSBpbiBgLm1pZGRsZXdhcmUoKWBcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogLm1pZGRsZXdhcmUoKG9wdHMpID0+IHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBbVVRGaWxlc106IG9wdHMuZmlsZXMubWFwKChmaWxlKSA9PiAoe1xuICogICAgICAgLi4uZmlsZSxcbiAqICAgICAgIGN1c3RvbUlkOiBnZW5lcmF0ZUlkKCksXG4gKiAgICAgfSkpXG4gKiAgIH07XG4gKiB9KVxuICogYGBgXG4gKi8gY29uc3QgVVRGaWxlcyA9IFN5bWJvbChcInVwbG9hZHRoaW5nLWN1c3RvbS1pZC1zeW1ib2xcIik7XG4vKipcbiAqIFZhbGlkIG9wdGlvbnMgZm9yIHRoZSBgP2FjdGlvblR5cGVgIHF1ZXJ5IHBhcmFtXG4gKi8gY29uc3QgVkFMSURfQUNUSU9OX1RZUEVTID0gW1xuICAgIFwidXBsb2FkXCIsXG4gICAgXCJmYWlsdXJlXCIsXG4gICAgXCJtdWx0aXBhcnQtY29tcGxldGVcIlxuXTtcblxuZXhwb3J0IHsgVVRGaWxlcywgVkFMSURfQUNUSU9OX1RZUEVTIH07XG4iXSwibmFtZXMiOlsiVVRGaWxlcyIsIlN5bWJvbCIsIlZBTElEX0FDVElPTl9UWVBFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uploadthing/internal/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/uploadthing/next/index.js":
/*!************************************************!*\
  !*** ./node_modules/uploadthing/next/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UTFiles: () => (/* reexport safe */ uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_1__.UTFiles),\n/* harmony export */   createNextRouteHandler: () => (/* binding */ createNextRouteHandler),\n/* harmony export */   createRouteHandler: () => (/* binding */ createRouteHandler),\n/* harmony export */   createUploadthing: () => (/* binding */ createUploadthing)\n/* harmony export */ });\n/* harmony import */ var uploadthing_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uploadthing/server */ \"(rsc)/./node_modules/uploadthing/server/index.js\");\n/* harmony import */ var uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uploadthing/internal/types */ \"(rsc)/./node_modules/uploadthing/internal/types.js\");\n\n\nfunction defaultErrorFormatter(error) {\n    return {\n        message: error.message\n    };\n}\nfunction internalCreateBuilder(initDef = {}) {\n    const _def = {\n        // Default router config\n        routerConfig: {\n            image: {\n                maxFileSize: \"4MB\"\n            }\n        },\n        inputParser: {\n            parse: ()=>undefined,\n            _input: undefined,\n            _output: undefined\n        },\n        middleware: ()=>({}),\n        onUploadError: ()=>({}),\n        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n        // Overload with properties passed in\n        ...initDef\n    };\n    return {\n        input (userParser) {\n            return internalCreateBuilder({\n                ..._def,\n                inputParser: userParser\n            });\n        },\n        middleware (userMiddleware) {\n            return internalCreateBuilder({\n                ..._def,\n                middleware: userMiddleware\n            });\n        },\n        onUploadComplete (userUploadComplete) {\n            return {\n                _def,\n                resolver: userUploadComplete\n            };\n        },\n        onUploadError (userOnUploadError) {\n            return internalCreateBuilder({\n                ..._def,\n                onUploadError: userOnUploadError\n            });\n        }\n    };\n}\nfunction createBuilder(opts) {\n    return (input)=>{\n        return internalCreateBuilder({\n            routerConfig: input,\n            ...opts\n        });\n    };\n}\nconst createUploadthing = (opts)=>createBuilder(opts);\nconst createRouteHandler = (opts)=>{\n    const handlers = (0,uploadthing_server__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_DO_NOT_USE_createRouteHandlerCore)(opts, \"nextjs-app\");\n    return {\n        POST: (req)=>handlers.POST(req),\n        GET: (req)=>handlers.GET(req)\n    };\n};\n/**\n * @deprecated Use {@link createRouteHandler} instead\n */ const createNextRouteHandler = createRouteHandler;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvbmV4dC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Y7QUFDM0I7QUFFckQsU0FBU0Usc0JBQXNCQyxLQUFLO0lBQ2hDLE9BQU87UUFDSEMsU0FBU0QsTUFBTUMsT0FBTztJQUMxQjtBQUNKO0FBRUEsU0FBU0Msc0JBQXNCQyxVQUFVLENBQUMsQ0FBQztJQUN2QyxNQUFNQyxPQUFPO1FBQ1Qsd0JBQXdCO1FBQ3hCQyxjQUFjO1lBQ1ZDLE9BQU87Z0JBQ0hDLGFBQWE7WUFDakI7UUFDSjtRQUNBQyxhQUFhO1lBQ1RDLE9BQU8sSUFBSUM7WUFDWEMsUUFBUUQ7WUFDUkUsU0FBU0Y7UUFDYjtRQUNBRyxZQUFZLElBQUssRUFBQztRQUNsQkMsZUFBZSxJQUFLLEVBQUM7UUFDckJDLGdCQUFnQlosUUFBUVksY0FBYyxJQUFJaEI7UUFDMUMscUNBQXFDO1FBQ3JDLEdBQUdJLE9BQU87SUFDZDtJQUNBLE9BQU87UUFDSGEsT0FBT0MsVUFBVTtZQUNiLE9BQU9mLHNCQUFzQjtnQkFDekIsR0FBR0UsSUFBSTtnQkFDUEksYUFBYVM7WUFDakI7UUFDSjtRQUNBSixZQUFZSyxjQUFjO1lBQ3RCLE9BQU9oQixzQkFBc0I7Z0JBQ3pCLEdBQUdFLElBQUk7Z0JBQ1BTLFlBQVlLO1lBQ2hCO1FBQ0o7UUFDQUMsa0JBQWtCQyxrQkFBa0I7WUFDaEMsT0FBTztnQkFDSGhCO2dCQUNBaUIsVUFBVUQ7WUFDZDtRQUNKO1FBQ0FOLGVBQWVRLGlCQUFpQjtZQUM1QixPQUFPcEIsc0JBQXNCO2dCQUN6QixHQUFHRSxJQUFJO2dCQUNQVSxlQUFlUTtZQUNuQjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNDLGNBQWNDLElBQUk7SUFDdkIsT0FBTyxDQUFDUjtRQUNKLE9BQU9kLHNCQUFzQjtZQUN6QkcsY0FBY1c7WUFDZCxHQUFHUSxJQUFJO1FBQ1g7SUFDSjtBQUNKO0FBRUEsTUFBTUMsb0JBQW9CLENBQUNELE9BQU9ELGNBQWNDO0FBQ2hELE1BQU1FLHFCQUFxQixDQUFDRjtJQUN4QixNQUFNRyxXQUFXOUIsOEZBQTBDQSxDQUFDMkIsTUFBTTtJQUNsRSxPQUFPO1FBQ0hJLE1BQU0sQ0FBQ0MsTUFBTUYsU0FBU0MsSUFBSSxDQUFDQztRQUMzQkMsS0FBSyxDQUFDRCxNQUFNRixTQUFTRyxHQUFHLENBQUNEO0lBQzdCO0FBQ0o7QUFDQTs7Q0FFQyxHQUFHLE1BQU1FLHlCQUF5Qkw7QUFFc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGx5Ly4vbm9kZV9tb2R1bGVzL3VwbG9hZHRoaW5nL25leHQvaW5kZXguanM/YzcwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUgfSBmcm9tICd1cGxvYWR0aGluZy9zZXJ2ZXInO1xuZXhwb3J0IHsgVVRGaWxlcyB9IGZyb20gJ3VwbG9hZHRoaW5nL2ludGVybmFsL3R5cGVzJztcblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yRm9ybWF0dGVyKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGludGVybmFsQ3JlYXRlQnVpbGRlcihpbml0RGVmID0ge30pIHtcbiAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICAvLyBEZWZhdWx0IHJvdXRlciBjb25maWdcbiAgICAgICAgcm91dGVyQ29uZmlnOiB7XG4gICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiBcIjRNQlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0UGFyc2VyOiB7XG4gICAgICAgICAgICBwYXJzZTogKCk9PnVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX291dHB1dDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZXdhcmU6ICgpPT4oe30pLFxuICAgICAgICBvblVwbG9hZEVycm9yOiAoKT0+KHt9KSxcbiAgICAgICAgZXJyb3JGb3JtYXR0ZXI6IGluaXREZWYuZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEVycm9yRm9ybWF0dGVyLFxuICAgICAgICAvLyBPdmVybG9hZCB3aXRoIHByb3BlcnRpZXMgcGFzc2VkIGluXG4gICAgICAgIC4uLmluaXREZWZcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0ICh1c2VyUGFyc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5fZGVmLFxuICAgICAgICAgICAgICAgIGlucHV0UGFyc2VyOiB1c2VyUGFyc2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxld2FyZSAodXNlck1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZTogdXNlck1pZGRsZXdhcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZENvbXBsZXRlICh1c2VyVXBsb2FkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2RlZixcbiAgICAgICAgICAgICAgICByZXNvbHZlcjogdXNlclVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZEVycm9yICh1c2VyT25VcGxvYWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBvblVwbG9hZEVycm9yOiB1c2VyT25VcGxvYWRFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQnVpbGRlcihvcHRzKSB7XG4gICAgcmV0dXJuIChpbnB1dCk9PntcbiAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICByb3V0ZXJDb25maWc6IGlucHV0LFxuICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5jb25zdCBjcmVhdGVVcGxvYWR0aGluZyA9IChvcHRzKT0+Y3JlYXRlQnVpbGRlcihvcHRzKTtcbmNvbnN0IGNyZWF0ZVJvdXRlSGFuZGxlciA9IChvcHRzKT0+e1xuICAgIGNvbnN0IGhhbmRsZXJzID0gSU5URVJOQUxfRE9fTk9UX1VTRV9jcmVhdGVSb3V0ZUhhbmRsZXJDb3JlKG9wdHMsIFwibmV4dGpzLWFwcFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBQT1NUOiAocmVxKT0+aGFuZGxlcnMuUE9TVChyZXEpLFxuICAgICAgICBHRVQ6IChyZXEpPT5oYW5kbGVycy5HRVQocmVxKVxuICAgIH07XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNyZWF0ZVJvdXRlSGFuZGxlcn0gaW5zdGVhZFxuICovIGNvbnN0IGNyZWF0ZU5leHRSb3V0ZUhhbmRsZXIgPSBjcmVhdGVSb3V0ZUhhbmRsZXI7XG5cbmV4cG9ydCB7IGNyZWF0ZU5leHRSb3V0ZUhhbmRsZXIsIGNyZWF0ZVJvdXRlSGFuZGxlciwgY3JlYXRlVXBsb2FkdGhpbmcgfTtcbiJdLCJuYW1lcyI6WyJJTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUiLCJVVEZpbGVzIiwiZGVmYXVsdEVycm9yRm9ybWF0dGVyIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW50ZXJuYWxDcmVhdGVCdWlsZGVyIiwiaW5pdERlZiIsIl9kZWYiLCJyb3V0ZXJDb25maWciLCJpbWFnZSIsIm1heEZpbGVTaXplIiwiaW5wdXRQYXJzZXIiLCJwYXJzZSIsInVuZGVmaW5lZCIsIl9pbnB1dCIsIl9vdXRwdXQiLCJtaWRkbGV3YXJlIiwib25VcGxvYWRFcnJvciIsImVycm9yRm9ybWF0dGVyIiwiaW5wdXQiLCJ1c2VyUGFyc2VyIiwidXNlck1pZGRsZXdhcmUiLCJvblVwbG9hZENvbXBsZXRlIiwidXNlclVwbG9hZENvbXBsZXRlIiwicmVzb2x2ZXIiLCJ1c2VyT25VcGxvYWRFcnJvciIsImNyZWF0ZUJ1aWxkZXIiLCJvcHRzIiwiY3JlYXRlVXBsb2FkdGhpbmciLCJjcmVhdGVSb3V0ZUhhbmRsZXIiLCJoYW5kbGVycyIsIlBPU1QiLCJyZXEiLCJHRVQiLCJjcmVhdGVOZXh0Um91dGVIYW5kbGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uploadthing/next/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/uploadthing/server/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/server/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_DO_NOT_USE_createRouteHandlerCore: () => (/* binding */ INTERNAL_DO_NOT_USE_createRouteHandlerCore),\n/* harmony export */   UTApi: () => (/* binding */ UTApi),\n/* harmony export */   UTFile: () => (/* binding */ UTFile),\n/* harmony export */   UTFiles: () => (/* reexport safe */ uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles),\n/* harmony export */   UploadThingError: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError),\n/* harmony export */   createRouteHandler: () => (/* binding */ createRouteHandler),\n/* harmony export */   createServerHandler: () => (/* binding */ createServerHandler),\n/* harmony export */   createUploadthing: () => (/* binding */ createUploadthing),\n/* harmony export */   extractRouterConfig: () => (/* binding */ extractRouterConfig)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(rsc)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! std-env */ \"(rsc)/./node_modules/std-env/dist/index.mjs\");\n/* harmony import */ var consola_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! consola/core */ \"(rsc)/./node_modules/consola/dist/core.mjs\");\n/* harmony import */ var uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uploadthing/internal/types */ \"(rsc)/./node_modules/uploadthing/internal/types.js\");\n/* harmony import */ var _uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @uploadthing/mime-types */ \"(rsc)/./node_modules/@uploadthing/mime-types/dist/index.js\");\n\n\n\n\n\n\n\nvar version = \"6.7.0\";\nfunction defaultErrorFormatter(error) {\n    return {\n        message: error.message\n    };\n}\nfunction formatError(error, router) {\n    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return errorFormatter(error);\n}\nconst colorize = (str, level)=>{\n    // TODO: Maybe check is shell supports colors\n    switch(level){\n        case \"error\":\n        case \"fatal\":\n            return `\\x1b[41m\\x1b[30m${str}\\x1b[0m`;\n        case \"warn\":\n            return `\\x1b[43m\\x1b[30m${str}\\x1b[0m`;\n        case \"info\":\n        case \"log\":\n            return `\\x1b[44m\\x1b[30m${str}\\x1b[0m`;\n        case \"debug\":\n            return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n        case \"trace\":\n            return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n        case \"success\":\n            return `\\x1b[42m\\x1b[30m${str}\\x1b[0m`;\n        default:\n            return str;\n    }\n};\nconst icons = {\n    fatal: \"\",\n    error: \"\",\n    warn: \"\",\n    info: \"\",\n    log: \"\",\n    debug: \"\",\n    trace: \"\",\n    success: \"\"\n};\nfunction formatStack(stack) {\n    const cwd = \"cwd\" in std_env__WEBPACK_IMPORTED_MODULE_4__.process && typeof std_env__WEBPACK_IMPORTED_MODULE_4__.process.cwd === \"function\" ? std_env__WEBPACK_IMPORTED_MODULE_4__.process.cwd() : \"__UnknownCWD__\";\n    return \"  \" + stack.split(\"\\n\").splice(1).map((l)=>l.trim().replace(\"file://\", \"\").replace(cwd + \"/\", \"\")).join(\"\\n  \");\n}\nfunction formatArgs(args) {\n    const fmtArgs = args.map((arg)=>{\n        if ((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(arg) && typeof arg.stack === \"string\") {\n            return arg.message + \"\\n\" + formatStack(arg.stack);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return arg;\n    });\n    return fmtArgs.map((arg)=>{\n        if (typeof arg === \"string\") {\n            return arg;\n        }\n        return JSON.stringify(arg, null, 4);\n    });\n}\nconst logger = (0,consola_core__WEBPACK_IMPORTED_MODULE_1__.createConsola)({\n    reporters: [\n        {\n            log: (logObj)=>{\n                const { type, tag, date, args } = logObj;\n                const icon = icons[type];\n                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);\n                const lines = formatArgs(args).join(\" \") // concat all arguments to one space-separated string (like console does)\n                .split(\"\\n\") // split all the newlines (e.g. from logged JSON.stringified objects)\n                .map((l)=>logPrefix + \" \" + l) // prepend the log prefix to each line\n                .join(\"\\n\"); // join all the lines back together\n                // eslint-disable-next-line no-console\n                console.log(lines);\n            }\n        }\n    ],\n    defaults: {\n        tag: \"UPLOADTHING\"\n    }\n});\nconst initLogger = (level)=>{\n    // logger.wrapConsole();\n    logger.level = consola_core__WEBPACK_IMPORTED_MODULE_1__.LogLevels[level ?? \"info\"];\n};\nconst isValidResponse = (response)=>{\n    if (!response.ok) return false;\n    if (response.status >= 400) return false;\n    if (!response.headers.has(\"x-uploadthing-version\")) return false;\n    return true;\n};\nconst conditionalDevServer = async (opts)=>{\n    const fileData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.pollForFileData)({\n        url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(`/api/pollUpload/${opts.fileKey}`),\n        apiKey: opts.apiKey,\n        sdkVersion: version,\n        fetch: opts.fetch\n    }, async (json)=>{\n        const file = json.fileData;\n        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n        if (!callbackUrl.startsWith(\"http\")) callbackUrl = \"http://\" + callbackUrl;\n        logger.info(\"SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n        const payload = JSON.stringify({\n            status: \"uploaded\",\n            metadata: JSON.parse(file.metadata ?? \"{}\"),\n            file: {\n                url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,\n                key: opts.fileKey,\n                name: file.fileName,\n                size: file.fileSize,\n                type: file.fileType,\n                customId: file.customId\n            }\n        });\n        const signature = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.signPayload)(payload, opts.apiKey);\n        try {\n            const response = await opts.fetch(callbackUrl, {\n                method: \"POST\",\n                body: payload,\n                headers: {\n                    \"uploadthing-hook\": \"callback\",\n                    \"x-uploadthing-signature\": signature\n                }\n            });\n            if (isValidResponse(response)) {\n                logger.success(\"Successfully simulated callback for file\", opts.fileKey);\n            } else {\n                throw new Error(\"Invalid response\");\n            }\n        } catch (e) {\n            logger.error(`Failed to simulate callback for file '${opts.fileKey}'. Is your webhook configured correctly?`);\n            logger.error(`  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal`);\n            logger.error(`  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues`);\n        }\n        return file;\n    });\n    if (fileData !== undefined) return fileData;\n    logger.error(`Failed to simulate callback for file ${opts.fileKey}`);\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"File took too long to upload\"\n    });\n};\nfunction getParseFn(parser) {\n    if (typeof parser.parse === \"function\") {\n        return parser.parse;\n    }\n    throw new Error(\"Invalid parser\");\n}\n/**\n * Creates a wrapped fetch that will always forward a few headers to the server.\n */ const createUTFetch = (apiKey, fetch, fePackage, beAdapter)=>{\n    return async (endpoint, payload)=>{\n        const response = await fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(endpoint), {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-api-key\": apiKey,\n                \"x-uploadthing-version\": version,\n                \"x-uploadthing-fe-package\": fePackage,\n                \"x-uploadthing-be-adapter\": beAdapter\n            }\n        });\n        return response;\n    };\n};\nconst fileCountLimitHit = (files, routeConfig)=>{\n    const counts = {};\n    files.forEach((file)=>{\n        const type = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig));\n        if (!counts[type]) {\n            counts[type] = 1;\n        } else {\n            counts[type] += 1;\n        }\n    });\n    for(const _key in counts){\n        const key = _key;\n        const count = counts[key];\n        const limit = routeConfig[key]?.maxFileCount;\n        if (!limit) {\n            logger.error(routeConfig, key);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Invalid config during file count\",\n                cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`\n            });\n        }\n        if (count > limit) {\n            return {\n                limitHit: true,\n                type: key,\n                limit,\n                count\n            };\n        }\n    }\n    return {\n        limitHit: false\n    };\n};\nconst buildRequestHandler = (opts, adapter)=>{\n    return async (input)=>{\n        const isDev = opts.config?.isDev ?? std_env__WEBPACK_IMPORTED_MODULE_4__.isDevelopment;\n        const fetch = opts.config?.fetch ?? globalThis.fetch;\n        if (isDev) {\n            logger.info(\"UploadThing dev server is now running!\");\n        }\n        const { router, config } = opts;\n        const preferredOrEnvSecret = config?.uploadthingSecret ?? std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n        const req = input.req;\n        const url = new URL(req.url);\n        // Get inputs from query and params\n        const params = url.searchParams;\n        const uploadthingHook = req.headers.get(\"uploadthing-hook\") ?? undefined;\n        const slug = params.get(\"slug\") ?? undefined;\n        const actionType = params.get(\"actionType\") ?? undefined;\n        const utFrontendPackage = req.headers.get(\"x-uploadthing-package\") ?? \"unknown\";\n        const clientVersion = req.headers.get(\"x-uploadthing-version\");\n        if (clientVersion != null && clientVersion !== version) {\n            logger.error(\"Client version mismatch\");\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Client version mismatch\",\n                cause: `Server version: ${version}, Client version: ${clientVersion}`\n            });\n        }\n        // Validate inputs\n        if (!slug) {\n            logger.error(\"No slug provided in params:\", params);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"No slug provided in params\"\n            });\n        }\n        if (slug && typeof slug !== \"string\") {\n            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`slug` must be a string\",\n                cause: msg\n            });\n        }\n        if (actionType && typeof actionType !== \"string\") {\n            const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`actionType` must be a string\",\n                cause: msg\n            });\n        }\n        if (uploadthingHook && typeof uploadthingHook !== \"string\") {\n            const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`uploadthingHook` must be a string\",\n                cause: msg\n            });\n        }\n        if (!preferredOrEnvSecret) {\n            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: `No secret provided`,\n                cause: msg\n            });\n        }\n        if (!preferredOrEnvSecret.startsWith(\"sk_\")) {\n            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: \"Invalid API key. API keys must start with 'sk_'.\",\n                cause: msg\n            });\n        }\n        if (utFrontendPackage && typeof utFrontendPackage !== \"string\") {\n            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`x-uploadthing-package` must be a string. eg. '@uploadthing/react'\",\n                cause: msg\n            });\n        }\n        const uploadable = router[slug];\n        if (!uploadable) {\n            const msg = `No file route found for slug ${slug}`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: msg\n            });\n        }\n        const utFetch = createUTFetch(preferredOrEnvSecret, fetch, utFrontendPackage, adapter);\n        logger.debug(\"All request input is valid\", {\n            slug,\n            actionType,\n            uploadthingHook\n        });\n        if (uploadthingHook === \"callback\") {\n            // This is when we receive the webhook from uploadthing\n            const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n            logger.debug(\"Handling callback request with input:\", maybeReqBody);\n            if (maybeReqBody instanceof Error) {\n                logger.error(\"Invalid request body\", maybeReqBody);\n                return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Invalid request body\",\n                    cause: maybeReqBody\n                });\n            }\n            const verified = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.verifySignature)(JSON.stringify(maybeReqBody), req.headers.get(\"x-uploadthing-signature\"), preferredOrEnvSecret);\n            logger.debug(\"Signature verified:\", verified);\n            if (!verified) {\n                logger.error(\"Invalid signature\");\n                return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Invalid signature\"\n                });\n            }\n            const resolverArgs = {\n                file: maybeReqBody.file,\n                metadata: maybeReqBody.metadata\n            };\n            logger.debug(\"Running 'onUploadComplete' callback with input:\", resolverArgs);\n            const res = await uploadable.resolver(resolverArgs);\n            const payload = {\n                fileKey: maybeReqBody.file.key,\n                callbackData: res ?? null\n            };\n            logger.debug(\"'onUploadComplete' callback finished. Sending response to UploadThing:\", payload);\n            const callbackResponse = await utFetch(\"/api/serverCallback\", payload);\n            logger.debug(\"UploadThing responded with status:\", callbackResponse.status);\n            return {\n                status: 200,\n                body: null\n            };\n        }\n        if (!actionType || !uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.VALID_ACTION_TYPES.includes(actionType)) {\n            // This would either be someone spamming or the AWS webhook\n            const msg = `Expected ${uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.VALID_ACTION_TYPES.map((x)=>`\"${x}\"`).join(\", \").replace(/,(?!.*,)/, \" or\")} but got \"${actionType}\"`;\n            logger.error(\"Invalid action type.\", msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                cause: `Invalid action type ${actionType}`,\n                message: msg\n            });\n        }\n        switch(actionType){\n            case \"upload\":\n                {\n                    const maybeInput = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeInput instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeInput);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeInput\n                        });\n                    }\n                    logger.debug(\"Handling upload request with input:\", maybeInput);\n                    const { files, input: userInput } = maybeInput;\n                    // Validate without Zod (for now)\n                    if (!Array.isArray(files) || !files.every((f)=>(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(f) && typeof f.name === \"string\" && typeof f.size === \"number\" && typeof f.type === \"string\")) {\n                        const msg = `Expected files to be of type '{name:string, size:number, type:string}[]', got '${JSON.stringify(files)}'`;\n                        logger.error(msg);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Files must be an array of objects with name and size\",\n                            cause: msg\n                        });\n                    }\n                    // validate the input\n                    let parsedInput = {};\n                    try {\n                        logger.debug(\"Parsing input\");\n                        const inputParser = uploadable._def.inputParser;\n                        parsedInput = await getParseFn(inputParser)(userInput);\n                        logger.debug(\"Input parsed successfully\", parsedInput);\n                    } catch (error) {\n                        logger.error(\"An error occurred trying to parse input:\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid input.\",\n                            cause: error\n                        });\n                    }\n                    let metadata = {};\n                    try {\n                        logger.debug(\"Running middleware\");\n                        metadata = await uploadable._def.middleware({\n                            ...input.middlewareArgs,\n                            input: parsedInput,\n                            files\n                        });\n                        logger.debug(\"Middleware finished successfully with:\", metadata);\n                    } catch (error) {\n                        logger.error(\"An error occurred in your middleware function:\", error);\n                        if (error instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError) return error;\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Failed to run middleware.\",\n                            cause: error\n                        });\n                    }\n                    if (metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles] && metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles].length !== files.length) {\n                        const msg = `Expected files override to have the same length as original files, got ${metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles].length} but expected ${files.length}`;\n                        logger.error(msg);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Files override must have the same length as files\",\n                            cause: msg\n                        });\n                    }\n                    // Attach customIds from middleware to the files\n                    const filesWithCustomIds = files.map((file, idx)=>{\n                        const theirs = metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles]?.[idx];\n                        if (theirs && theirs.size !== file.size) {\n                            logger.warn(\"File size mismatch. Reverting to original size\");\n                        }\n                        return {\n                            name: theirs?.name ?? file.name,\n                            size: file.size,\n                            customId: theirs?.customId\n                        };\n                    });\n                    // FILL THE ROUTE CONFIG so the server only has one happy path\n                    let parsedConfig;\n                    try {\n                        logger.debug(\"Parsing route config\", uploadable._def.routerConfig);\n                        parsedConfig = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fillInputRouteConfig)(uploadable._def.routerConfig);\n                        logger.debug(\"Route config parsed successfully\", parsedConfig);\n                    } catch (error) {\n                        logger.error(\"Invalid route config\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid config.\",\n                            cause: error\n                        });\n                    }\n                    try {\n                        logger.debug(\"Checking file count limit\", files);\n                        const { limitHit, count, limit, type } = fileCountLimitHit(files, parsedConfig);\n                        if (limitHit) {\n                            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;\n                            logger.error(msg);\n                            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"BAD_REQUEST\",\n                                message: \"File limit exceeded\",\n                                cause: msg\n                            });\n                        }\n                        logger.debug(\"File count limit check passed\");\n                    } catch (error) {\n                        logger.error(\"Invalid route config\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid config.\",\n                            cause: error\n                        });\n                    }\n                    const callbackUrl = resolveCallbackUrl({\n                        config,\n                        req,\n                        url,\n                        isDev\n                    });\n                    logger.debug(\"Retrieving presigned URLs from UploadThing. Callback URL is:\", callbackUrl.href);\n                    const uploadthingApiResponse = await utFetch(\"/api/prepareUpload\", {\n                        files: filesWithCustomIds,\n                        routeConfig: parsedConfig,\n                        metadata,\n                        callbackUrl: callbackUrl.origin + callbackUrl.pathname,\n                        callbackSlug: slug\n                    });\n                    // This is when we send the response back to the user's form so they can submit the files\n                    const parsedResponse = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(uploadthingApiResponse);\n                    if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {\n                        logger.error(\"Unable to get presigned URLs\", parsedResponse);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"URL_GENERATION_FAILED\",\n                            message: \"Unable to get presigned urls\",\n                            cause: parsedResponse\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", parsedResponse);\n                    logger.debug(\"Sending presigned URLs to client\");\n                    // This is when we send the response back to the user's form so they can submit the files\n                    let promise = undefined;\n                    if (isDev) {\n                        promise = Promise.all(parsedResponse.map((file)=>conditionalDevServer({\n                                fileKey: file.key,\n                                apiKey: preferredOrEnvSecret,\n                                fetch\n                            }).catch((error)=>{\n                                logger.error(\"Err\", error);\n                            })));\n                    }\n                    return {\n                        cleanup: promise,\n                        body: parsedResponse,\n                        status: 200\n                    };\n                }\n            case \"multipart-complete\":\n                {\n                    const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeReqBody instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeReqBody);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeReqBody\n                        });\n                    }\n                    logger.debug(\"Handling multipart-complete request with input:\", maybeReqBody);\n                    logger.debug(\"Notifying UploadThing that multipart upload is complete\");\n                    const completeRes = await utFetch(\"/api/completeMultipart\", {\n                        fileKey: maybeReqBody.fileKey,\n                        uploadId: maybeReqBody.uploadId,\n                        etags: maybeReqBody.etags\n                    });\n                    if (!completeRes.ok) {\n                        logger.error(\"Failed to notify UploadThing that multipart upload is complete\");\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: \"Failed to complete multipart upload\",\n                            cause: completeRes\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", completeRes.status);\n                    return {\n                        status: 200,\n                        body: null\n                    };\n                }\n            case \"failure\":\n                {\n                    const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeReqBody instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeReqBody);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeReqBody\n                        });\n                    }\n                    const { fileKey, uploadId } = maybeReqBody;\n                    logger.debug(\"Handling failure request with input:\", maybeReqBody);\n                    logger.debug(\"Notifying UploadThing that upload failed\");\n                    // Tell uploadthing to mark the upload as failed\n                    const uploadthingApiResponse = await utFetch(\"/api/failureCallback\", {\n                        fileKey,\n                        uploadId\n                    });\n                    if (!uploadthingApiResponse.ok) {\n                        const parsedResponse = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(uploadthingApiResponse);\n                        logger.error(\"Failed to mark upload as failed\", parsedResponse);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Unable to mark upload as failed\",\n                            cause: parsedResponse\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", uploadthingApiResponse);\n                    logger.debug(\"Running 'onUploadError' callback\");\n                    try {\n                        // Run the onUploadError callback\n                        uploadable._def.onUploadError({\n                            error: new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"UPLOAD_FAILED\",\n                                message: `Upload failed for ${fileKey}`\n                            }),\n                            fileKey\n                        });\n                    } catch (error) {\n                        logger.error(\"Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Failed to run onUploadError callback\",\n                            cause: error\n                        });\n                    }\n                    return {\n                        status: 200,\n                        body: null\n                    };\n                }\n            default:\n                {\n                    // This should never happen\n                    return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                        code: \"BAD_REQUEST\",\n                        message: `Invalid action type`\n                    });\n                }\n        }\n    };\n};\nfunction resolveCallbackUrl(opts) {\n    let callbackUrl = opts.url;\n    if (opts.config?.callbackUrl) {\n        callbackUrl = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(opts.config.callbackUrl);\n    } else if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_URL) {\n        callbackUrl = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_URL);\n    }\n    if (opts.isDev || !callbackUrl.host.includes(\"localhost\")) {\n        return callbackUrl;\n    }\n    // Production builds have to have a public URL so UT can send webhook\n    // Parse the URL from the headers\n    const headers = opts.req.headers;\n    let parsedFromHeaders = headers.get(\"origin\") ?? headers.get(\"referer\") ?? headers.get(\"host\") ?? headers.get(\"x-forwarded-host\");\n    if (parsedFromHeaders && !parsedFromHeaders.includes(\"http\")) {\n        parsedFromHeaders = (headers.get(\"x-forwarded-proto\") ?? \"https\") + \"://\" + parsedFromHeaders;\n    }\n    if (!parsedFromHeaders || parsedFromHeaders.includes(\"localhost\")) {\n        // Didn't find a valid URL in the headers, log a warning and use the original url anyway\n        logger.warn(\"You are using a localhost callback url in production which is not supported.\", \"Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production\");\n        return callbackUrl;\n    }\n    return (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(parsedFromHeaders);\n}\nconst buildPermissionsInfoHandler = (opts)=>{\n    return ()=>{\n        const r = opts.router;\n        const permissions = Object.keys(r).map((k)=>{\n            const route = r[k];\n            const config = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fillInputRouteConfig)(route._def.routerConfig);\n            return {\n                slug: k,\n                config\n            };\n        });\n        return permissions;\n    };\n};\nfunction incompatibleNodeGuard() {\n    if (typeof std_env__WEBPACK_IMPORTED_MODULE_4__.process === \"undefined\") return;\n    let major;\n    let minor;\n    const maybeNodeVersion = std_env__WEBPACK_IMPORTED_MODULE_4__.process.versions?.node?.split(\".\");\n    if (maybeNodeVersion) {\n        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));\n    }\n    const maybeNodePath = std_env__WEBPACK_IMPORTED_MODULE_4__.process.env?.NODE;\n    if (!major && maybeNodePath) {\n        const nodeVersion = /v(\\d+)\\.(\\d+)\\.(\\d+)/.exec(maybeNodePath)?.[0];\n        if (nodeVersion) {\n            [major, minor] = nodeVersion.substring(1).split(\".\").map((v)=>parseInt(v, 10));\n        }\n    }\n    if (!major || !minor) return;\n    // Require ^18.13.0\n    if (major > 18) return;\n    if (major === 18 && minor >= 13) return;\n    logger.fatal(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`);\n    // Kill the process if it isn't going to work correctly anyway\n    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    std_env__WEBPACK_IMPORTED_MODULE_4__.process.exit?.(1);\n}\nfunction internalCreateBuilder(initDef = {}) {\n    const _def = {\n        // Default router config\n        routerConfig: {\n            image: {\n                maxFileSize: \"4MB\"\n            }\n        },\n        inputParser: {\n            parse: ()=>undefined,\n            _input: undefined,\n            _output: undefined\n        },\n        middleware: ()=>({}),\n        onUploadError: ()=>({}),\n        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n        // Overload with properties passed in\n        ...initDef\n    };\n    return {\n        input (userParser) {\n            return internalCreateBuilder({\n                ..._def,\n                inputParser: userParser\n            });\n        },\n        middleware (userMiddleware) {\n            return internalCreateBuilder({\n                ..._def,\n                middleware: userMiddleware\n            });\n        },\n        onUploadComplete (userUploadComplete) {\n            return {\n                _def,\n                resolver: userUploadComplete\n            };\n        },\n        onUploadError (userOnUploadError) {\n            return internalCreateBuilder({\n                ..._def,\n                onUploadError: userOnUploadError\n            });\n        }\n    };\n}\nfunction createBuilder(opts) {\n    return (input)=>{\n        return internalCreateBuilder({\n            routerConfig: input,\n            ...opts\n        });\n    };\n}\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n/**\n * Used by server uploads where progress is not needed.\n * Uses normal fetch API.\n */ async function uploadPart(opts, retryCount = 0) {\n    const s3Res = await opts.fetch(opts.url, {\n        method: \"PUT\",\n        body: opts.chunk,\n        headers: {\n            \"Content-Type\": opts.contentType,\n            \"Content-Disposition\": (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName)\n        }\n    });\n    if (s3Res.ok) {\n        const etag = s3Res.headers.get(\"Etag\");\n        if (!etag) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"UPLOAD_FAILED\",\n                message: \"Missing Etag header from uploaded part\"\n            });\n        }\n        return etag.replace(/\"/g, \"\");\n    }\n    if (retryCount < opts.maxRetries) {\n        // Retry after exponential backoff\n        const delay = 2 ** retryCount * 1000;\n        await new Promise((r)=>setTimeout(r, delay));\n        return uploadPart(opts, retryCount++);\n    }\n    // Max retries exceeded, tell UT server that upload failed\n    await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/failureCallback\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n            fileKey: opts.key\n        }),\n        headers: opts.utRequestHeaders\n    });\n    const text = await s3Res.text();\n    const parsed = maybeParseResponseXML(text);\n    if (parsed?.message) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: parsed.message\n        });\n    }\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"Failed to upload file to storage provider\",\n        cause: s3Res\n    });\n}\nfunction guardServerOnly() {\n    if (false) {}\n}\nfunction getApiKeyOrThrow(apiKey) {\n    if (apiKey) return apiKey;\n    if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET) return std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"MISSING_ENV\",\n        message: \"Missing `UPLOADTHING_SECRET` env variable.\"\n    });\n}\nconst uploadFilesInternal = async (data, opts)=>{\n    // Request presigned URLs for each file\n    const fileData = data.files.map((file)=>({\n            name: file.name ?? \"unnamed-blob\",\n            type: file.type,\n            size: file.size,\n            ...\"customId\" in file ? {\n                customId: file.customId\n            } : {}\n        }));\n    logger.debug(\"Getting presigned URLs for files\", fileData);\n    const res = await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/uploadFiles\"), {\n        method: \"POST\",\n        headers: opts.utRequestHeaders,\n        cache: \"no-store\",\n        body: JSON.stringify({\n            files: fileData,\n            metadata: data.metadata,\n            contentDisposition: data.contentDisposition,\n            acl: data.acl\n        })\n    });\n    if (!res.ok) {\n        const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(res);\n        logger.debug(\"Failed getting presigned URLs:\", error);\n        throw error;\n    }\n    const json = await res.json();\n    logger.debug(\"Got presigned URLs:\", json.data);\n    logger.debug(\"Starting uploads...\");\n    // Upload each file to S3 in chunks using multi-part uploads\n    const uploads = await Promise.allSettled(data.files.map(async (file, i)=>{\n        const presigned = json.data[i];\n        if (!presigned) {\n            logger.error(\"Failed to generate presigned URL for file:\", file, presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"URL_GENERATION_FAILED\",\n                message: \"Failed to generate presigned URL\",\n                cause: JSON.stringify(presigned)\n            });\n        }\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                ...opts\n            });\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                ...opts\n            });\n        }\n        // Poll for file to be available\n        logger.debug(\"Polling for file data...\");\n        await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.pollForFileData)({\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(`/api/pollUpload/${presigned.key}`),\n            apiKey: opts.utRequestHeaders[\"x-uploadthing-api-key\"],\n            sdkVersion: version,\n            fetch: opts.fetch\n        });\n        logger.debug(\"Polling complete.\");\n        return {\n            key: presigned.key,\n            url: presigned.fileUrl,\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            customId: \"customId\" in file ? file.customId ?? null : null\n        };\n    }));\n    logger.debug(\"All uploads complete, aggregating results...\");\n    return uploads.map((upload)=>{\n        if (upload.status === \"fulfilled\") {\n            const data = upload.value;\n            return {\n                data,\n                error: null\n            };\n        }\n        // We only throw UploadThingErrors, so this is safe\n        const reason = upload.reason;\n        const error = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(reason);\n        return {\n            data: null,\n            error\n        };\n    });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    logger.debug(\"Uploading file\", file.name, \"with\", presigned.urls.length, \"chunks of size\", presigned.chunkSize, \"bytes each\");\n    const etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n        const offset = presigned.chunkSize * index;\n        const end = Math.min(offset + presigned.chunkSize, file.size);\n        const chunk = file.slice(offset, end);\n        const etag = await uploadPart({\n            fetch: opts.fetch,\n            url,\n            chunk: chunk,\n            contentDisposition: presigned.contentDisposition,\n            contentType: file.type,\n            fileName: file.name,\n            maxRetries: 10,\n            key: presigned.key,\n            utRequestHeaders: opts.utRequestHeaders\n        });\n        logger.debug(\"Part\", index + 1, \"uploaded successfully:\", etag);\n        return {\n            tag: etag,\n            partNumber: index + 1\n        };\n    }));\n    logger.debug(\"File\", file.name, \"uploaded successfully. Notifying UploadThing to complete multipart upload.\");\n    // Complete multipart upload\n    const completionRes = await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/completeMultipart\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            etags\n        }),\n        headers: opts.utRequestHeaders\n    });\n    logger.debug(\"UploadThing responsed with status:\", completionRes.status);\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    logger.debug(\"Uploading file\", file.name, \"using presigned POST URL\");\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const res = await opts.fetch(presigned.url, {\n        method: \"POST\",\n        body: formData,\n        headers: new Headers({\n            Accept: \"application/xml\"\n        })\n    });\n    if (!res.ok) {\n        const text = await res.text();\n        logger.error(\"Failed to upload file:\", text);\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to upload file\",\n            cause: text\n        });\n    }\n    logger.debug(\"File\", file.name, \"uploaded successfully\");\n}\nfunction parseTimeToSeconds(time) {\n    const match = time.toString().split(/(\\d+)/).filter(Boolean);\n    const num = Number(match[0]);\n    const unit = (match[1] ?? \"s\").trim().slice(0, 1);\n    const multiplier = {\n        s: 1,\n        m: 60,\n        h: 3600,\n        d: 86400\n    }[unit];\n    return num * multiplier;\n}\n/**\n * Extension of the Blob class that simplifies setting the `name` and `customId` properties,\n * similar to the built-in File class from Node > 20.\n */ class UTFile extends Blob {\n    constructor(parts, name, options){\n        const optionsWithDefaults = {\n            ...options,\n            type: options?.type ?? ((0,_uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_3__.lookup)(name) || undefined),\n            lastModified: options?.lastModified ?? Date.now()\n        };\n        super(parts, optionsWithDefaults);\n        this.name = name;\n        this.customId = optionsWithDefaults.customId;\n        this.lastModified = optionsWithDefaults.lastModified;\n    }\n}\nclass UTApi {\n    constructor(opts){\n        /**\n   * Request to delete files from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   *\n   * @example\n   * await deleteFiles(\"myCustomIdentifier\", { keyType: \"customId\" })\n   */ this.deleteFiles = async (keys, opts)=>{\n            guardServerOnly();\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            return this.requestUploadThing(\"/api/deleteFile\", keyType === \"fileKey\" ? {\n                fileKeys: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            } : {\n                customIds: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            }, \"An unknown error occurred while deleting files.\");\n        };\n        /**\n   * Request file URLs from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n   *\n   * @example\n   * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n   */ this.getFileUrls = async (keys, opts)=>{\n            guardServerOnly();\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            const json = await this.requestUploadThing(\"/api/getFileUrl\", keyType === \"fileKey\" ? {\n                fileKeys: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            } : {\n                customIds: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            }, \"An unknown error occurred while retrieving file URLs.\");\n            return json.data;\n        };\n        /**\n   * Request file list from UploadThing storage.\n   * @param {object} opts\n   * @param {number} opts.limit The maximum number of files to return\n   * @param {number} opts.offset The number of files to skip\n   *\n   * @example\n   * const data = await listFiles({ limit: 1 });\n   * console.log(data); // { key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", id: \"2e0fdb64-9957-4262-8e45-f372ba903ac8\" }\n   */ this.listFiles = async (opts)=>{\n            guardServerOnly();\n            const json = await this.requestUploadThing(\"/api/listFiles\", {\n                ...opts\n            }, \"An unknown error occurred while listing files.\");\n            return json.files;\n        };\n        this.renameFiles = async (updates)=>{\n            guardServerOnly();\n            return this.requestUploadThing(\"/api/renameFiles\", {\n                updates: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(updates)\n            }, \"An unknown error occurred while renaming files.\");\n        };\n        /** @deprecated Use {@link renameFiles} instead. */ this.renameFile = this.renameFiles;\n        this.getUsageInfo = async ()=>{\n            guardServerOnly();\n            return this.requestUploadThing(\"/api/getUsageInfo\", {}, \"An unknown error occurred while getting usage info.\");\n        };\n        /** Request a presigned url for a private file(s) */ this.getSignedURL = async (key, opts)=>{\n            guardServerOnly();\n            const expiresIn = opts?.expiresIn ? parseTimeToSeconds(opts.expiresIn) : undefined;\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            if (opts?.expiresIn && isNaN(expiresIn)) {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds.\"\n                });\n            }\n            if (expiresIn && expiresIn > 86400 * 7) {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"expiresIn must be less than 7 days (604800 seconds).\"\n                });\n            }\n            const json = await this.requestUploadThing(\"/api/requestFileAccess\", keyType === \"fileKey\" ? {\n                fileKey: key,\n                expiresIn\n            } : {\n                customId: key,\n                expiresIn\n            }, \"An unknown error occurred while retrieving presigned URLs.\");\n            return json.url;\n        };\n        this.fetch = opts?.fetch ?? globalThis.fetch;\n        this.apiKey = opts?.apiKey ?? std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n        this.defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-api-key\": this.apiKey,\n            \"x-uploadthing-version\": version,\n            \"x-uploadthing-be-adapter\": \"server-sdk\"\n        };\n        this.defaultKeyType = opts?.defaultKeyType ?? \"fileKey\";\n        initLogger(opts?.logLevel);\n        // Assert some stuff\n        guardServerOnly();\n        getApiKeyOrThrow(this.apiKey);\n        if (!this.apiKey?.startsWith(\"sk_\")) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: \"Invalid API key. API keys must start with `sk_`.\"\n            });\n        }\n        incompatibleNodeGuard();\n    }\n    async requestUploadThing(pathname, body, fallbackErrorMessage) {\n        const url = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(pathname);\n        logger.debug(\"Requesting UploadThing:\", {\n            url,\n            body,\n            headers: this.defaultHeaders\n        });\n        const res = await this.fetch(url, {\n            method: \"POST\",\n            cache: \"no-store\",\n            headers: this.defaultHeaders,\n            body: JSON.stringify(body)\n        });\n        logger.debug(\"UploadThing responsed with status:\", res.status);\n        const json = await res.json();\n        if (!res.ok || \"error\" in json) {\n            logger.error(\"Error:\", json);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"INTERNAL_SERVER_ERROR\",\n                message: \"error\" in json && typeof json.error === \"string\" ? json.error : fallbackErrorMessage\n            });\n        }\n        logger.debug(\"UploadThing response:\", json);\n        return json;\n    }\n    async uploadFiles(files, opts) {\n        guardServerOnly();\n        const uploads = await uploadFilesInternal({\n            files: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(files),\n            metadata: opts?.metadata ?? {},\n            contentDisposition: opts?.contentDisposition ?? \"inline\",\n            acl: opts?.acl\n        }, {\n            fetch: this.fetch,\n            utRequestHeaders: this.defaultHeaders\n        });\n        const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];\n        logger.debug(\"Finished uploading:\", uploadFileResponse);\n        return uploadFileResponse;\n    }\n    async uploadFilesFromUrl(urls, opts) {\n        guardServerOnly();\n        const formData = new FormData();\n        formData.append(\"metadata\", JSON.stringify(opts?.metadata ?? {}));\n        const downloadErrors = {};\n        const files = await Promise.all((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(urls).map(async (_url, index)=>{\n            let url = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(_url) ? _url.url : _url;\n            if (typeof url === \"string\") {\n                // since dataurls will result in name being too long, tell the user\n                // to use uploadFiles instead.\n                if (url.startsWith(\"data:\")) {\n                    downloadErrors[index] = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                        code: \"BAD_REQUEST\",\n                        message: \"Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only.\"\n                    }));\n                    return undefined;\n                }\n                url = new URL(url);\n            }\n            const { name = url.pathname.split(\"/\").pop() ?? \"unknown-filename\", customId = undefined } = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(_url) ? _url : {};\n            // Download the file on the user's server to avoid egress charges\n            logger.debug(\"Downloading file:\", url);\n            const fileResponse = await this.fetch(url);\n            if (!fileResponse.ok) {\n                downloadErrors[index] = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Failed to download requested file.\",\n                    cause: fileResponse\n                }));\n                return undefined;\n            }\n            logger.debug(\"Finished downloading file. Reading blob...\");\n            const blob = await fileResponse.blob();\n            logger.debug(\"Finished reading blob.\");\n            return new UTFile([\n                blob\n            ], name, {\n                customId\n            });\n        })).then((files)=>files.filter((x)=>x !== undefined));\n        logger.debug(\"Uploading files:\", files);\n        const uploads = await uploadFilesInternal({\n            files,\n            metadata: opts?.metadata ?? {},\n            contentDisposition: opts?.contentDisposition ?? \"inline\",\n            acl: opts?.acl\n        }, {\n            fetch: this.fetch,\n            utRequestHeaders: this.defaultHeaders\n        });\n        /** Put it all back together, preserve the order of files */ const responses = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(urls).map((_, index)=>{\n            if (downloadErrors[index]) {\n                return {\n                    data: null,\n                    error: downloadErrors[index]\n                };\n            }\n            return uploads.shift();\n        });\n        /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];\n        logger.debug(\"Finished uploading:\", uploadFileResponse);\n        return uploadFileResponse;\n    }\n}\nconst createUploadthing = (opts)=>createBuilder(opts);\n/** @internal */ const INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter)=>{\n    initLogger(opts.config?.logLevel);\n    incompatibleNodeGuard();\n    const requestHandler = buildRequestHandler(opts, adapter);\n    const getBuildPerms = buildPermissionsInfoHandler(opts);\n    const POST = async (request)=>{\n        const req = request instanceof Request ? request : request.request;\n        const response = await requestHandler({\n            req,\n            middlewareArgs: {\n                req,\n                res: undefined,\n                event: undefined\n            }\n        });\n        if (response instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError) {\n            return new Response(JSON.stringify(formatError(response, opts.router)), {\n                status: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getStatusCodeFromError)(response),\n                headers: {\n                    \"x-uploadthing-version\": version\n                }\n            });\n        }\n        if (response.status !== 200) {\n            // We messed up - this should never happen\n            return new Response(\"An unknown error occurred\", {\n                status: 500,\n                headers: {\n                    \"x-uploadthing-version\": version\n                }\n            });\n        }\n        const res = new Response(JSON.stringify(response.body), {\n            status: response.status,\n            headers: {\n                \"x-uploadthing-version\": version\n            }\n        });\n        // @ts-expect-error - this is a custom property\n        res.cleanup = response.cleanup;\n        return res;\n    };\n    const GET = (request)=>{\n        return new Response(JSON.stringify(getBuildPerms()), {\n            status: 200,\n            headers: {\n                \"x-uploadthing-version\": version\n            }\n        });\n    };\n    return {\n        GET,\n        POST\n    };\n};\nconst createRouteHandler = (opts)=>INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, \"server\");\nconst extractRouterConfig = (router)=>buildPermissionsInfoHandler({\n        router\n    })();\n/**\n * @deprecated Use {@link createRouteHandler} instead\n */ const createServerHandler = createRouteHandler;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvc2VydmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVSO0FBQ2hPO0FBQ047QUFDTztBQUNpQjtBQUNwQjtBQUNKO0FBRWpELElBQUlxQixVQUFVO0FBRWQsU0FBU0Msc0JBQXNCQyxLQUFLO0lBQ2hDLE9BQU87UUFDSEMsU0FBU0QsTUFBTUMsT0FBTztJQUMxQjtBQUNKO0FBQ0EsU0FBU0MsWUFBWUYsS0FBSyxFQUFFRyxNQUFNO0lBQzlCLE1BQU1DLGlCQUFpQkQsTUFBTSxDQUFDRSxPQUFPQyxJQUFJLENBQUNILE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRUksS0FBS0gsa0JBQWtCTDtJQUM5RSwrREFBK0Q7SUFDL0QsT0FBT0ssZUFBZUo7QUFDMUI7QUFFQSxNQUFNUSxXQUFXLENBQUNDLEtBQUtDO0lBQ25CLDZDQUE2QztJQUM3QyxPQUFPQTtRQUNILEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTyxDQUFDLGdCQUFnQixFQUFFRCxJQUFJLE9BQU8sQ0FBQztRQUMxQyxLQUFLO1lBQ0QsT0FBTyxDQUFDLGdCQUFnQixFQUFFQSxJQUFJLE9BQU8sQ0FBQztRQUMxQyxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRUEsSUFBSSxPQUFPLENBQUM7UUFDMUMsS0FBSztZQUNELE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRUEsSUFBSSxPQUFPLENBQUM7UUFDMUMsS0FBSztZQUNELE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRUEsSUFBSSxPQUFPLENBQUM7UUFDMUMsS0FBSztZQUNELE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRUEsSUFBSSxPQUFPLENBQUM7UUFDMUM7WUFDSSxPQUFPQTtJQUNmO0FBQ0o7QUFDQSxNQUFNRSxRQUFRO0lBQ1ZDLE9BQU87SUFDUFosT0FBTztJQUNQYSxNQUFNO0lBQ05DLE1BQU07SUFDTkMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLE9BQU87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O1FBQ0o7UUFDQSxJQUFJbEMsb0JBQW9CcEUsaUVBQWdCQSxFQUFFO1lBQ3RDLE9BQU8sSUFBSXFWLFNBQVNqUyxLQUFLQyxTQUFTLENBQUNoQyxZQUFZK0MsVUFBVU0sS0FBS3BELE1BQU0sSUFBSTtnQkFDcEVnRCxRQUFRN0QsMkVBQXNCQSxDQUFDMkQ7Z0JBQy9CRyxTQUFTO29CQUNMLHlCQUF5QnREO2dCQUM3QjtZQUNKO1FBQ0o7UUFDQSxJQUFJbUQsU0FBU0UsTUFBTSxLQUFLLEtBQUs7WUFDekIsMENBQTBDO1lBQzFDLE9BQU8sSUFBSStRLFNBQVMsNkJBQTZCO2dCQUM3Qy9RLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ0wseUJBQXlCdEQ7Z0JBQzdCO1lBQ0o7UUFDSjtRQUNBLE1BQU1rSSxNQUFNLElBQUlrTSxTQUFTalMsS0FBS0MsU0FBUyxDQUFDZSxTQUFTK0IsSUFBSSxHQUFHO1lBQ3BEN0IsUUFBUUYsU0FBU0UsTUFBTTtZQUN2QkMsU0FBUztnQkFDTCx5QkFBeUJ0RDtZQUM3QjtRQUNKO1FBQ0EsK0NBQStDO1FBQy9Da0ksSUFBSWdDLE9BQU8sR0FBRy9HLFNBQVMrRyxPQUFPO1FBQzlCLE9BQU9oQztJQUNYO0lBQ0EsTUFBTW1NLE1BQU0sQ0FBQ0o7UUFDVCxPQUFPLElBQUlHLFNBQVNqUyxLQUFLQyxTQUFTLENBQUMyUixrQkFBa0I7WUFDakQxUSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ0wseUJBQXlCdEQ7WUFDN0I7UUFDSjtJQUNKO0lBQ0EsT0FBTztRQUNIcVU7UUFDQUw7SUFDSjtBQUNKO0FBQ0EsTUFBTU0scUJBQXFCLENBQUM3USxPQUFPb1EsMkNBQTJDcFEsTUFBTTtBQUNwRixNQUFNOFEsc0JBQXNCLENBQUNsVSxTQUFTcUssNEJBQTRCO1FBQzFEcks7SUFDSjtBQUNKOztDQUVDLEdBQUcsTUFBTW1VLHNCQUFzQkY7QUFFc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGx5Ly4vbm9kZV9tb2R1bGVzL3VwbG9hZHRoaW5nL3NlcnZlci9pbmRleC5qcz9lYjY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzT2JqZWN0LCBwb2xsRm9yRmlsZURhdGEsIGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwsIHNpZ25QYXlsb2FkLCBVcGxvYWRUaGluZ0Vycm9yLCBmaWxsSW5wdXRSb3V0ZUNvbmZpZywgc2FmZVBhcnNlSlNPTiwgdmVyaWZ5U2lnbmF0dXJlLCByZXNvbHZlTWF5YmVVcmxBcmcsIGdldFR5cGVGcm9tRmlsZU5hbWUsIG9iamVjdEtleXMsIGNvbnRlbnREaXNwb3NpdGlvbiwgYXNBcnJheSwgZ2V0U3RhdHVzQ29kZUZyb21FcnJvciB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuZXhwb3J0IHsgVXBsb2FkVGhpbmdFcnJvciB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuaW1wb3J0IHsgcHJvY2VzcywgaXNEZXZlbG9wbWVudCB9IGZyb20gJ3N0ZC1lbnYnO1xuaW1wb3J0IHsgY3JlYXRlQ29uc29sYSwgTG9nTGV2ZWxzIH0gZnJvbSAnY29uc29sYS9jb3JlJztcbmltcG9ydCB7IFZBTElEX0FDVElPTl9UWVBFUywgVVRGaWxlcyB9IGZyb20gJ3VwbG9hZHRoaW5nL2ludGVybmFsL3R5cGVzJztcbmV4cG9ydCB7IFVURmlsZXMgfSBmcm9tICd1cGxvYWR0aGluZy9pbnRlcm5hbC90eXBlcyc7XG5pbXBvcnQgeyBsb29rdXAgfSBmcm9tICdAdXBsb2FkdGhpbmcvbWltZS10eXBlcyc7XG5cbnZhciB2ZXJzaW9uID0gXCI2LjcuMFwiO1xuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JGb3JtYXR0ZXIoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycm9yLCByb3V0ZXIpIHtcbiAgICBjb25zdCBlcnJvckZvcm1hdHRlciA9IHJvdXRlcltPYmplY3Qua2V5cyhyb3V0ZXIpWzBdXT8uX2RlZi5lcnJvckZvcm1hdHRlciA/PyBkZWZhdWx0RXJyb3JGb3JtYXR0ZXI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgcmV0dXJuIGVycm9yRm9ybWF0dGVyKGVycm9yKTtcbn1cblxuY29uc3QgY29sb3JpemUgPSAoc3RyLCBsZXZlbCk9PntcbiAgICAvLyBUT0RPOiBNYXliZSBjaGVjayBpcyBzaGVsbCBzdXBwb3J0cyBjb2xvcnNcbiAgICBzd2l0Y2gobGV2ZWwpe1xuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY2FzZSBcImZhdGFsXCI6XG4gICAgICAgICAgICByZXR1cm4gYFxceDFiWzQxbVxceDFiWzMwbSR7c3RyfVxceDFiWzBtYDtcbiAgICAgICAgY2FzZSBcIndhcm5cIjpcbiAgICAgICAgICAgIHJldHVybiBgXFx4MWJbNDNtXFx4MWJbMzBtJHtzdHJ9XFx4MWJbMG1gO1xuICAgICAgICBjYXNlIFwiaW5mb1wiOlxuICAgICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgICAgICByZXR1cm4gYFxceDFiWzQ0bVxceDFiWzMwbSR7c3RyfVxceDFiWzBtYDtcbiAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICByZXR1cm4gYFxceDFiWzQ3bVxceDFiWzMwbSR7c3RyfVxceDFiWzBtYDtcbiAgICAgICAgY2FzZSBcInRyYWNlXCI6XG4gICAgICAgICAgICByZXR1cm4gYFxceDFiWzQ3bVxceDFiWzMwbSR7c3RyfVxceDFiWzBtYDtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgIHJldHVybiBgXFx4MWJbNDJtXFx4MWJbMzBtJHtzdHJ9XFx4MWJbMG1gO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuY29uc3QgaWNvbnMgPSB7XG4gICAgZmF0YWw6IFwi4qivXCIsXG4gICAgZXJyb3I6IFwi4qivXCIsXG4gICAgd2FybjogXCLimqDvuI9cIixcbiAgICBpbmZvOiBcIuKEuVwiLFxuICAgIGxvZzogXCLihLlcIixcbiAgICBkZWJ1ZzogXCLimplcIixcbiAgICB0cmFjZTogXCLihpJcIixcbiAgICBzdWNjZXNzOiBcIuKck1wiXG59O1xuZnVuY3Rpb24gZm9ybWF0U3RhY2soc3RhY2spIHtcbiAgICBjb25zdCBjd2QgPSBcImN3ZFwiIGluIHByb2Nlc3MgJiYgdHlwZW9mIHByb2Nlc3MuY3dkID09PSBcImZ1bmN0aW9uXCIgPyBwcm9jZXNzLmN3ZCgpIDogXCJfX1Vua25vd25DV0RfX1wiO1xuICAgIHJldHVybiBcIiAgXCIgKyBzdGFjay5zcGxpdChcIlxcblwiKS5zcGxpY2UoMSkubWFwKChsKT0+bC50cmltKCkucmVwbGFjZShcImZpbGU6Ly9cIiwgXCJcIikucmVwbGFjZShjd2QgKyBcIi9cIiwgXCJcIikpLmpvaW4oXCJcXG4gIFwiKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICAgIGNvbnN0IGZtdEFyZ3MgPSBhcmdzLm1hcCgoYXJnKT0+e1xuICAgICAgICBpZiAoaXNPYmplY3QoYXJnKSAmJiB0eXBlb2YgYXJnLnN0YWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2UgKyBcIlxcblwiICsgZm9ybWF0U3RhY2soYXJnLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9KTtcbiAgICByZXR1cm4gZm10QXJncy5tYXAoKGFyZyk9PntcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZywgbnVsbCwgNCk7XG4gICAgfSk7XG59XG5jb25zdCBsb2dnZXIgPSBjcmVhdGVDb25zb2xhKHtcbiAgICByZXBvcnRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbG9nOiAobG9nT2JqKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgdGFnLCBkYXRlLCBhcmdzIH0gPSBsb2dPYmo7XG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGljb25zW3R5cGVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ1ByZWZpeCA9IGNvbG9yaXplKGAgJHtpY29ufSAke3RhZ30gJHtkYXRlLnRvTG9jYWxlVGltZVN0cmluZygpfSBgLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGZvcm1hdEFyZ3MoYXJncykuam9pbihcIiBcIikgLy8gY29uY2F0IGFsbCBhcmd1bWVudHMgdG8gb25lIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgKGxpa2UgY29uc29sZSBkb2VzKVxuICAgICAgICAgICAgICAgIC5zcGxpdChcIlxcblwiKSAvLyBzcGxpdCBhbGwgdGhlIG5ld2xpbmVzIChlLmcuIGZyb20gbG9nZ2VkIEpTT04uc3RyaW5naWZpZWQgb2JqZWN0cylcbiAgICAgICAgICAgICAgICAubWFwKChsKT0+bG9nUHJlZml4ICsgXCIgXCIgKyBsKSAvLyBwcmVwZW5kIHRoZSBsb2cgcHJlZml4IHRvIGVhY2ggbGluZVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpOyAvLyBqb2luIGFsbCB0aGUgbGluZXMgYmFjayB0b2dldGhlclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobGluZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICB0YWc6IFwiVVBMT0FEVEhJTkdcIlxuICAgIH1cbn0pO1xuY29uc3QgaW5pdExvZ2dlciA9IChsZXZlbCk9PntcbiAgICAvLyBsb2dnZXIud3JhcENvbnNvbGUoKTtcbiAgICBsb2dnZXIubGV2ZWwgPSBMb2dMZXZlbHNbbGV2ZWwgPz8gXCJpbmZvXCJdO1xufTtcblxuY29uc3QgaXNWYWxpZFJlc3BvbnNlID0gKHJlc3BvbnNlKT0+e1xuICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybiBmYWxzZTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghcmVzcG9uc2UuaGVhZGVycy5oYXMoXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIikpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBjb25kaXRpb25hbERldlNlcnZlciA9IGFzeW5jIChvcHRzKT0+e1xuICAgIGNvbnN0IGZpbGVEYXRhID0gYXdhaXQgcG9sbEZvckZpbGVEYXRhKHtcbiAgICAgICAgdXJsOiBnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKGAvYXBpL3BvbGxVcGxvYWQvJHtvcHRzLmZpbGVLZXl9YCksXG4gICAgICAgIGFwaUtleTogb3B0cy5hcGlLZXksXG4gICAgICAgIHNka1ZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIGZldGNoOiBvcHRzLmZldGNoXG4gICAgfSwgYXN5bmMgKGpzb24pPT57XG4gICAgICAgIGNvbnN0IGZpbGUgPSBqc29uLmZpbGVEYXRhO1xuICAgICAgICBsZXQgY2FsbGJhY2tVcmwgPSBmaWxlLmNhbGxiYWNrVXJsICsgYD9zbHVnPSR7ZmlsZS5jYWxsYmFja1NsdWd9YDtcbiAgICAgICAgaWYgKCFjYWxsYmFja1VybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkgY2FsbGJhY2tVcmwgPSBcImh0dHA6Ly9cIiArIGNhbGxiYWNrVXJsO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIlNJTVVMQVRJTkcgRklMRSBVUExPQUQgV0VCSE9PSyBDQUxMQkFDS1wiLCBjYWxsYmFja1VybCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzdGF0dXM6IFwidXBsb2FkZWRcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBKU09OLnBhcnNlKGZpbGUubWV0YWRhdGEgPz8gXCJ7fVwiKSxcbiAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGBodHRwczovL3V0ZnMuaW8vZi8ke2VuY29kZVVSSUNvbXBvbmVudChvcHRzLmZpbGVLZXkpfWAsXG4gICAgICAgICAgICAgICAga2V5OiBvcHRzLmZpbGVLZXksXG4gICAgICAgICAgICAgICAgbmFtZTogZmlsZS5maWxlTmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmaWxlLmZpbGVTaXplLFxuICAgICAgICAgICAgICAgIHR5cGU6IGZpbGUuZmlsZVR5cGUsXG4gICAgICAgICAgICAgICAgY3VzdG9tSWQ6IGZpbGUuY3VzdG9tSWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25QYXlsb2FkKHBheWxvYWQsIG9wdHMuYXBpS2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3B0cy5mZXRjaChjYWxsYmFja1VybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgYm9keTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidXBsb2FkdGhpbmctaG9va1wiOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1zaWduYXR1cmVcIjogc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5zdWNjZXNzKFwiU3VjY2Vzc2Z1bGx5IHNpbXVsYXRlZCBjYWxsYmFjayBmb3IgZmlsZVwiLCBvcHRzLmZpbGVLZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBzaW11bGF0ZSBjYWxsYmFjayBmb3IgZmlsZSAnJHtvcHRzLmZpbGVLZXl9Jy4gSXMgeW91ciB3ZWJob29rIGNvbmZpZ3VyZWQgY29ycmVjdGx5P2ApO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAgIC0gTWFrZSBzdXJlIHRoZSBVUkwgJyR7Y2FsbGJhY2tVcmx9JyBpcyBhY2Nlc3NpYmxlIHdpdGhvdXQgYW55IGF1dGhlbnRpY2F0aW9uLiBZb3UgY2FuIHZlcmlmeSB0aGlzIGJ5IHJ1bm5pbmcgJ2N1cmwgLVggUE9TVCAke2NhbGxiYWNrVXJsfScgaW4geW91ciB0ZXJtaW5hbGApO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAgIC0gU3RpbGwgZmFjaW5nIGlzc3Vlcz8gUmVhZCBodHRwczovL2RvY3MudXBsb2FkdGhpbmcuY29tL2ZhcSBmb3IgY29tbW9uIGlzc3Vlc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH0pO1xuICAgIGlmIChmaWxlRGF0YSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZmlsZURhdGE7XG4gICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gc2ltdWxhdGUgY2FsbGJhY2sgZm9yIGZpbGUgJHtvcHRzLmZpbGVLZXl9YCk7XG4gICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgbWVzc2FnZTogXCJGaWxlIHRvb2sgdG9vIGxvbmcgdG8gdXBsb2FkXCJcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldFBhcnNlRm4ocGFyc2VyKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIucGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcnNlclwiKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgd3JhcHBlZCBmZXRjaCB0aGF0IHdpbGwgYWx3YXlzIGZvcndhcmQgYSBmZXcgaGVhZGVycyB0byB0aGUgc2VydmVyLlxuICovIGNvbnN0IGNyZWF0ZVVURmV0Y2ggPSAoYXBpS2V5LCBmZXRjaCwgZmVQYWNrYWdlLCBiZUFkYXB0ZXIpPT57XG4gICAgcmV0dXJuIGFzeW5jIChlbmRwb2ludCwgcGF5bG9hZCk9PntcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKGVuZHBvaW50KSwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1hcGkta2V5XCI6IGFwaUtleSxcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1mZS1wYWNrYWdlXCI6IGZlUGFja2FnZSxcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctYmUtYWRhcHRlclwiOiBiZUFkYXB0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xufTtcbmNvbnN0IGZpbGVDb3VudExpbWl0SGl0ID0gKGZpbGVzLCByb3V0ZUNvbmZpZyk9PntcbiAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICBmaWxlcy5mb3JFYWNoKChmaWxlKT0+e1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZUZyb21GaWxlTmFtZShmaWxlLm5hbWUsIG9iamVjdEtleXMocm91dGVDb25maWcpKTtcbiAgICAgICAgaWYgKCFjb3VudHNbdHlwZV0pIHtcbiAgICAgICAgICAgIGNvdW50c1t0eXBlXSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudHNbdHlwZV0gKz0gMTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvcihjb25zdCBfa2V5IGluIGNvdW50cyl7XG4gICAgICAgIGNvbnN0IGtleSA9IF9rZXk7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzW2tleV07XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gcm91dGVDb25maWdba2V5XT8ubWF4RmlsZUNvdW50O1xuICAgICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3Iocm91dGVDb25maWcsIGtleSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBjb25maWcgZHVyaW5nIGZpbGUgY291bnRcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogYEV4cGVjdGVkIHJvdXRlIGNvbmZpZyB0byBoYXZlIGEgbWF4RmlsZUNvdW50IGZvciBrZXkgJHtrZXl9IGJ1dCBub25lIHdhcyBmb3VuZC5gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPiBsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaW1pdEhpdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICAgICAgY291bnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGltaXRIaXQ6IGZhbHNlXG4gICAgfTtcbn07XG5jb25zdCBidWlsZFJlcXVlc3RIYW5kbGVyID0gKG9wdHMsIGFkYXB0ZXIpPT57XG4gICAgcmV0dXJuIGFzeW5jIChpbnB1dCk9PntcbiAgICAgICAgY29uc3QgaXNEZXYgPSBvcHRzLmNvbmZpZz8uaXNEZXYgPz8gaXNEZXZlbG9wbWVudDtcbiAgICAgICAgY29uc3QgZmV0Y2ggPSBvcHRzLmNvbmZpZz8uZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICAgICAgaWYgKGlzRGV2KSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIlVwbG9hZFRoaW5nIGRldiBzZXJ2ZXIgaXMgbm93IHJ1bm5pbmchXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcm91dGVyLCBjb25maWcgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHByZWZlcnJlZE9yRW52U2VjcmV0ID0gY29uZmlnPy51cGxvYWR0aGluZ1NlY3JldCA/PyBwcm9jZXNzLmVudi5VUExPQURUSElOR19TRUNSRVQ7XG4gICAgICAgIGNvbnN0IHJlcSA9IGlucHV0LnJlcTtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICAgICAgLy8gR2V0IGlucHV0cyBmcm9tIHF1ZXJ5IGFuZCBwYXJhbXNcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgICAgICAgY29uc3QgdXBsb2FkdGhpbmdIb29rID0gcmVxLmhlYWRlcnMuZ2V0KFwidXBsb2FkdGhpbmctaG9va1wiKSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNsdWcgPSBwYXJhbXMuZ2V0KFwic2x1Z1wiKSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBwYXJhbXMuZ2V0KFwiYWN0aW9uVHlwZVwiKSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHV0RnJvbnRlbmRQYWNrYWdlID0gcmVxLmhlYWRlcnMuZ2V0KFwieC11cGxvYWR0aGluZy1wYWNrYWdlXCIpID8/IFwidW5rbm93blwiO1xuICAgICAgICBjb25zdCBjbGllbnRWZXJzaW9uID0gcmVxLmhlYWRlcnMuZ2V0KFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCIpO1xuICAgICAgICBpZiAoY2xpZW50VmVyc2lvbiAhPSBudWxsICYmIGNsaWVudFZlcnNpb24gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkNsaWVudCB2ZXJzaW9uIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDbGllbnQgdmVyc2lvbiBtaXNtYXRjaFwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgU2VydmVyIHZlcnNpb246ICR7dmVyc2lvbn0sIENsaWVudCB2ZXJzaW9uOiAke2NsaWVudFZlcnNpb259YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXRzXG4gICAgICAgIGlmICghc2x1Zykge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiTm8gc2x1ZyBwcm92aWRlZCBpbiBwYXJhbXM6XCIsIHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIHNsdWcgcHJvdmlkZWQgaW4gcGFyYW1zXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbHVnICYmIHR5cGVvZiBzbHVnICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgc2x1ZyB0byBiZSBvZiB0eXBlICdzdHJpbmcnLCBnb3QgJyR7dHlwZW9mIHNsdWd9J2A7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiYHNsdWdgIG11c3QgYmUgYSBzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uVHlwZSAmJiB0eXBlb2YgYWN0aW9uVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIGFjdGlvblR5cGUgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgZ290ICcke3R5cGVvZiBhY3Rpb25UeXBlfSdgO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImBhY3Rpb25UeXBlYCBtdXN0IGJlIGEgc3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwbG9hZHRoaW5nSG9vayAmJiB0eXBlb2YgdXBsb2FkdGhpbmdIb29rICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgdXBsb2FkdGhpbmdIb29rIHRvIGJlIG9mIHR5cGUgJ3N0cmluZycsIGdvdCAnJHt0eXBlb2YgdXBsb2FkdGhpbmdIb29rfSdgO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJgdXBsb2FkdGhpbmdIb29rYCBtdXN0IGJlIGEgc3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVmZXJyZWRPckVudlNlY3JldCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYE5vIHNlY3JldCBwcm92aWRlZCwgcGxlYXNlIHNldCBVUExPQURUSElOR19TRUNSRVQgaW4geW91ciBlbnYgZmlsZSBvciBpbiB0aGUgY29uZmlnYDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIk1JU1NJTkdfRU5WXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIHNlY3JldCBwcm92aWRlZGAsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmVmZXJyZWRPckVudlNlY3JldC5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgSW52YWxpZCBzZWNyZXQgcHJvdmlkZWQsIFVQTE9BRFRISU5HX1NFQ1JFVCBtdXN0IHN0YXJ0IHdpdGggJ3NrXydgO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiTUlTU0lOR19FTlZcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgQVBJIGtleS4gQVBJIGtleXMgbXVzdCBzdGFydCB3aXRoICdza18nLlwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dEZyb250ZW5kUGFja2FnZSAmJiB0eXBlb2YgdXRGcm9udGVuZFBhY2thZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCB4LXVwbG9hZHRoaW5nLXBhY2thZ2UgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgZ290ICcke3R5cGVvZiB1dEZyb250ZW5kUGFja2FnZX0nYDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJgeC11cGxvYWR0aGluZy1wYWNrYWdlYCBtdXN0IGJlIGEgc3RyaW5nLiBlZy4gJ0B1cGxvYWR0aGluZy9yZWFjdCdcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRhYmxlID0gcm91dGVyW3NsdWddO1xuICAgICAgICBpZiAoIXVwbG9hZGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBObyBmaWxlIHJvdXRlIGZvdW5kIGZvciBzbHVnICR7c2x1Z31gO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1dEZldGNoID0gY3JlYXRlVVRGZXRjaChwcmVmZXJyZWRPckVudlNlY3JldCwgZmV0Y2gsIHV0RnJvbnRlbmRQYWNrYWdlLCBhZGFwdGVyKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQWxsIHJlcXVlc3QgaW5wdXQgaXMgdmFsaWRcIiwge1xuICAgICAgICAgICAgc2x1ZyxcbiAgICAgICAgICAgIGFjdGlvblR5cGUsXG4gICAgICAgICAgICB1cGxvYWR0aGluZ0hvb2tcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGxvYWR0aGluZ0hvb2sgPT09IFwiY2FsbGJhY2tcIikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGVuIHdlIHJlY2VpdmUgdGhlIHdlYmhvb2sgZnJvbSB1cGxvYWR0aGluZ1xuICAgICAgICAgICAgY29uc3QgbWF5YmVSZXFCb2R5ID0gYXdhaXQgc2FmZVBhcnNlSlNPTihyZXEpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSGFuZGxpbmcgY2FsbGJhY2sgcmVxdWVzdCB3aXRoIGlucHV0OlwiLCBtYXliZVJlcUJvZHkpO1xuICAgICAgICAgICAgaWYgKG1heWJlUmVxQm9keSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIiwgbWF5YmVSZXFCb2R5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1heWJlUmVxQm9keVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCB2ZXJpZnlTaWduYXR1cmUoSlNPTi5zdHJpbmdpZnkobWF5YmVSZXFCb2R5KSwgcmVxLmhlYWRlcnMuZ2V0KFwieC11cGxvYWR0aGluZy1zaWduYXR1cmVcIiksIHByZWZlcnJlZE9yRW52U2VjcmV0KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlNpZ25hdHVyZSB2ZXJpZmllZDpcIiwgdmVyaWZpZWQpO1xuICAgICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgc2lnbmF0dXJlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHNpZ25hdHVyZVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgZmlsZTogbWF5YmVSZXFCb2R5LmZpbGUsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1heWJlUmVxQm9keS5tZXRhZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJ1bm5pbmcgJ29uVXBsb2FkQ29tcGxldGUnIGNhbGxiYWNrIHdpdGggaW5wdXQ6XCIsIHJlc29sdmVyQXJncyk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB1cGxvYWRhYmxlLnJlc29sdmVyKHJlc29sdmVyQXJncyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGZpbGVLZXk6IG1heWJlUmVxQm9keS5maWxlLmtleSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja0RhdGE6IHJlcyA/PyBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiJ29uVXBsb2FkQ29tcGxldGUnIGNhbGxiYWNrIGZpbmlzaGVkLiBTZW5kaW5nIHJlc3BvbnNlIHRvIFVwbG9hZFRoaW5nOlwiLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrUmVzcG9uc2UgPSBhd2FpdCB1dEZldGNoKFwiL2FwaS9zZXJ2ZXJDYWxsYmFja1wiLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbmRlZCB3aXRoIHN0YXR1czpcIiwgY2FsbGJhY2tSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICBib2R5OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWN0aW9uVHlwZSB8fCAhVkFMSURfQUNUSU9OX1RZUEVTLmluY2x1ZGVzKGFjdGlvblR5cGUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIGVpdGhlciBiZSBzb21lb25lIHNwYW1taW5nIG9yIHRoZSBBV1Mgd2ViaG9va1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7VkFMSURfQUNUSU9OX1RZUEVTLm1hcCgoeCk9PmBcIiR7eH1cImApLmpvaW4oXCIsIFwiKS5yZXBsYWNlKC8sKD8hLiosKS8sIFwiIG9yXCIpfSBidXQgZ290IFwiJHthY3Rpb25UeXBlfVwiYDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgYWN0aW9uIHR5cGUuXCIsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogYEludmFsaWQgYWN0aW9uIHR5cGUgJHthY3Rpb25UeXBlfWAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goYWN0aW9uVHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwidXBsb2FkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZUlucHV0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTihyZXEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVJbnB1dCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLCBtYXliZUlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogbWF5YmVJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSGFuZGxpbmcgdXBsb2FkIHJlcXVlc3Qgd2l0aCBpbnB1dDpcIiwgbWF5YmVJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsZXMsIGlucHV0OiB1c2VySW5wdXQgfSA9IG1heWJlSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHdpdGhvdXQgWm9kIChmb3Igbm93KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5ldmVyeSgoZik9PmlzT2JqZWN0KGYpICYmIHR5cGVvZiBmLm5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGYuc2l6ZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZi50eXBlID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIGZpbGVzIHRvIGJlIG9mIHR5cGUgJ3tuYW1lOnN0cmluZywgc2l6ZTpudW1iZXIsIHR5cGU6c3RyaW5nfVtdJywgZ290ICcke0pTT04uc3RyaW5naWZ5KGZpbGVzKX0nYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGaWxlcyBtdXN0IGJlIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBuYW1lIGFuZCBzaXplXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhlIGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRJbnB1dCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUGFyc2luZyBpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0UGFyc2VyID0gdXBsb2FkYWJsZS5fZGVmLmlucHV0UGFyc2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSBhd2FpdCBnZXRQYXJzZUZuKGlucHV0UGFyc2VyKSh1c2VySW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSW5wdXQgcGFyc2VkIHN1Y2Nlc3NmdWxseVwiLCBwYXJzZWRJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCB0cnlpbmcgdG8gcGFyc2UgaW5wdXQ6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBpbnB1dC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUnVubmluZyBtaWRkbGV3YXJlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBhd2FpdCB1cGxvYWRhYmxlLl9kZWYubWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5wdXQubWlkZGxld2FyZUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnNlZElucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIk1pZGRsZXdhcmUgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5IHdpdGg6XCIsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIGluIHlvdXIgbWlkZGxld2FyZSBmdW5jdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVXBsb2FkVGhpbmdFcnJvcikgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHJ1biBtaWRkbGV3YXJlLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhW1VURmlsZXNdICYmIG1ldGFkYXRhW1VURmlsZXNdLmxlbmd0aCAhPT0gZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgZmlsZXMgb3ZlcnJpZGUgdG8gaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgb3JpZ2luYWwgZmlsZXMsIGdvdCAke21ldGFkYXRhW1VURmlsZXNdLmxlbmd0aH0gYnV0IGV4cGVjdGVkICR7ZmlsZXMubGVuZ3RofWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmlsZXMgb3ZlcnJpZGUgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyBmaWxlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCBjdXN0b21JZHMgZnJvbSBtaWRkbGV3YXJlIHRvIHRoZSBmaWxlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlc1dpdGhDdXN0b21JZHMgPSBmaWxlcy5tYXAoKGZpbGUsIGlkeCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZWlycyA9IG1ldGFkYXRhW1VURmlsZXNdPy5baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGVpcnMgJiYgdGhlaXJzLnNpemUgIT09IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRmlsZSBzaXplIG1pc21hdGNoLiBSZXZlcnRpbmcgdG8gb3JpZ2luYWwgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhlaXJzPy5uYW1lID8/IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tSWQ6IHRoZWlycz8uY3VzdG9tSWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSUxMIFRIRSBST1VURSBDT05GSUcgc28gdGhlIHNlcnZlciBvbmx5IGhhcyBvbmUgaGFwcHkgcGF0aFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUGFyc2luZyByb3V0ZSBjb25maWdcIiwgdXBsb2FkYWJsZS5fZGVmLnJvdXRlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRDb25maWcgPSBmaWxsSW5wdXRSb3V0ZUNvbmZpZyh1cGxvYWRhYmxlLl9kZWYucm91dGVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJvdXRlIGNvbmZpZyBwYXJzZWQgc3VjY2Vzc2Z1bGx5XCIsIHBhcnNlZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHJvdXRlIGNvbmZpZ1wiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgY29uZmlnLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNoZWNraW5nIGZpbGUgY291bnQgbGltaXRcIiwgZmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsaW1pdEhpdCwgY291bnQsIGxpbWl0LCB0eXBlIH0gPSBmaWxlQ291bnRMaW1pdEhpdChmaWxlcywgcGFyc2VkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdEhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBZb3UgdXBsb2FkZWQgJHtjb3VudH0gZmlsZXMgb2YgdHlwZSAnJHt0eXBlfScsIGJ1dCB0aGUgbGltaXQgZm9yIHRoYXQgdHlwZSBpcyAke2xpbWl0fWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZpbGUgbGltaXQgZXhjZWVkZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmlsZSBjb3VudCBsaW1pdCBjaGVjayBwYXNzZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHJvdXRlIGNvbmZpZ1wiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgY29uZmlnLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tVcmwgPSByZXNvbHZlQ2FsbGJhY2tVcmwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZXZcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJldHJpZXZpbmcgcHJlc2lnbmVkIFVSTHMgZnJvbSBVcGxvYWRUaGluZy4gQ2FsbGJhY2sgVVJMIGlzOlwiLCBjYWxsYmFja1VybC5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBsb2FkdGhpbmdBcGlSZXNwb25zZSA9IGF3YWl0IHV0RmV0Y2goXCIvYXBpL3ByZXBhcmVVcGxvYWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGZpbGVzV2l0aEN1c3RvbUlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlQ29uZmlnOiBwYXJzZWRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsOiBjYWxsYmFja1VybC5vcmlnaW4gKyBjYWxsYmFja1VybC5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrU2x1Zzogc2x1Z1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGVuIHdlIHNlbmQgdGhlIHJlc3BvbnNlIGJhY2sgdG8gdGhlIHVzZXIncyBmb3JtIHNvIHRoZXkgY2FuIHN1Ym1pdCB0aGUgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHVwbG9hZHRoaW5nQXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVwbG9hZHRoaW5nQXBpUmVzcG9uc2Uub2sgfHwgcGFyc2VkUmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiVW5hYmxlIHRvIGdldCBwcmVzaWduZWQgVVJMc1wiLCBwYXJzZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVVJMX0dFTkVSQVRJT05fRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJVbmFibGUgdG8gZ2V0IHByZXNpZ25lZCB1cmxzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlZFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25kZWQgd2l0aDpcIiwgcGFyc2VkUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJTZW5kaW5nIHByZXNpZ25lZCBVUkxzIHRvIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGVuIHdlIHNlbmQgdGhlIHJlc3BvbnNlIGJhY2sgdG8gdGhlIHVzZXIncyBmb3JtIHNvIHRoZXkgY2FuIHN1Ym1pdCB0aGUgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Rldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcnNlZFJlc3BvbnNlLm1hcCgoZmlsZSk9PmNvbmRpdGlvbmFsRGV2U2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUtleTogZmlsZS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleTogcHJlZmVycmVkT3JFbnZTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXA6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJzZWRSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGFydC1jb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVSZXFCb2R5ID0gYXdhaXQgc2FmZVBhcnNlSlNPTihyZXEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVSZXFCb2R5IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsIG1heWJlUmVxQm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1heWJlUmVxQm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiSGFuZGxpbmcgbXVsdGlwYXJ0LWNvbXBsZXRlIHJlcXVlc3Qgd2l0aCBpbnB1dDpcIiwgbWF5YmVSZXFCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTm90aWZ5aW5nIFVwbG9hZFRoaW5nIHRoYXQgbXVsdGlwYXJ0IHVwbG9hZCBpcyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVSZXMgPSBhd2FpdCB1dEZldGNoKFwiL2FwaS9jb21wbGV0ZU11bHRpcGFydFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlS2V5OiBtYXliZVJlcUJvZHkuZmlsZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZElkOiBtYXliZVJlcUJvZHkudXBsb2FkSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldGFnczogbWF5YmVSZXFCb2R5LmV0YWdzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsZXRlUmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbm90aWZ5IFVwbG9hZFRoaW5nIHRoYXQgbXVsdGlwYXJ0IHVwbG9hZCBpcyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gY29tcGxldGUgbXVsdGlwYXJ0IHVwbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBjb21wbGV0ZVJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uZGVkIHdpdGg6XCIsIGNvbXBsZXRlUmVzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVSZXFCb2R5ID0gYXdhaXQgc2FmZVBhcnNlSlNPTihyZXEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVSZXFCb2R5IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsIG1heWJlUmVxQm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1heWJlUmVxQm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlS2V5LCB1cGxvYWRJZCB9ID0gbWF5YmVSZXFCb2R5O1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJIYW5kbGluZyBmYWlsdXJlIHJlcXVlc3Qgd2l0aCBpbnB1dDpcIiwgbWF5YmVSZXFCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTm90aWZ5aW5nIFVwbG9hZFRoaW5nIHRoYXQgdXBsb2FkIGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGVsbCB1cGxvYWR0aGluZyB0byBtYXJrIHRoZSB1cGxvYWQgYXMgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwbG9hZHRoaW5nQXBpUmVzcG9uc2UgPSBhd2FpdCB1dEZldGNoKFwiL2FwaS9mYWlsdXJlQ2FsbGJhY2tcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZElkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVwbG9hZHRoaW5nQXBpUmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJlc3BvbnNlID0gYXdhaXQgc2FmZVBhcnNlSlNPTih1cGxvYWR0aGluZ0FwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBtYXJrIHVwbG9hZCBhcyBmYWlsZWRcIiwgcGFyc2VkUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5hYmxlIHRvIG1hcmsgdXBsb2FkIGFzIGZhaWxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBwYXJzZWRSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uZGVkIHdpdGg6XCIsIHVwbG9hZHRoaW5nQXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJSdW5uaW5nICdvblVwbG9hZEVycm9yJyBjYWxsYmFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgb25VcGxvYWRFcnJvciBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkYWJsZS5fZGVmLm9uVXBsb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVXBsb2FkIGZhaWxlZCBmb3IgJHtmaWxlS2V5fWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBydW4gb25VcGxvYWRFcnJvciBjYWxsYmFjay4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBiZSB0aHJvd2luZyBlcnJvcnMgaW4geW91ciBjYWxsYmFjay5cIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHJ1biBvblVwbG9hZEVycm9yIGNhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEludmFsaWQgYWN0aW9uIHR5cGVgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUNhbGxiYWNrVXJsKG9wdHMpIHtcbiAgICBsZXQgY2FsbGJhY2tVcmwgPSBvcHRzLnVybDtcbiAgICBpZiAob3B0cy5jb25maWc/LmNhbGxiYWNrVXJsKSB7XG4gICAgICAgIGNhbGxiYWNrVXJsID0gcmVzb2x2ZU1heWJlVXJsQXJnKG9wdHMuY29uZmlnLmNhbGxiYWNrVXJsKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LlVQTE9BRFRISU5HX1VSTCkge1xuICAgICAgICBjYWxsYmFja1VybCA9IHJlc29sdmVNYXliZVVybEFyZyhwcm9jZXNzLmVudi5VUExPQURUSElOR19VUkwpO1xuICAgIH1cbiAgICBpZiAob3B0cy5pc0RldiB8fCAhY2FsbGJhY2tVcmwuaG9zdC5pbmNsdWRlcyhcImxvY2FsaG9zdFwiKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tVcmw7XG4gICAgfVxuICAgIC8vIFByb2R1Y3Rpb24gYnVpbGRzIGhhdmUgdG8gaGF2ZSBhIHB1YmxpYyBVUkwgc28gVVQgY2FuIHNlbmQgd2ViaG9va1xuICAgIC8vIFBhcnNlIHRoZSBVUkwgZnJvbSB0aGUgaGVhZGVyc1xuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLnJlcS5oZWFkZXJzO1xuICAgIGxldCBwYXJzZWRGcm9tSGVhZGVycyA9IGhlYWRlcnMuZ2V0KFwib3JpZ2luXCIpID8/IGhlYWRlcnMuZ2V0KFwicmVmZXJlclwiKSA/PyBoZWFkZXJzLmdldChcImhvc3RcIikgPz8gaGVhZGVycy5nZXQoXCJ4LWZvcndhcmRlZC1ob3N0XCIpO1xuICAgIGlmIChwYXJzZWRGcm9tSGVhZGVycyAmJiAhcGFyc2VkRnJvbUhlYWRlcnMuaW5jbHVkZXMoXCJodHRwXCIpKSB7XG4gICAgICAgIHBhcnNlZEZyb21IZWFkZXJzID0gKGhlYWRlcnMuZ2V0KFwieC1mb3J3YXJkZWQtcHJvdG9cIikgPz8gXCJodHRwc1wiKSArIFwiOi8vXCIgKyBwYXJzZWRGcm9tSGVhZGVycztcbiAgICB9XG4gICAgaWYgKCFwYXJzZWRGcm9tSGVhZGVycyB8fCBwYXJzZWRGcm9tSGVhZGVycy5pbmNsdWRlcyhcImxvY2FsaG9zdFwiKSkge1xuICAgICAgICAvLyBEaWRuJ3QgZmluZCBhIHZhbGlkIFVSTCBpbiB0aGUgaGVhZGVycywgbG9nIGEgd2FybmluZyBhbmQgdXNlIHRoZSBvcmlnaW5hbCB1cmwgYW55d2F5XG4gICAgICAgIGxvZ2dlci53YXJuKFwiWW91IGFyZSB1c2luZyBhIGxvY2FsaG9zdCBjYWxsYmFjayB1cmwgaW4gcHJvZHVjdGlvbiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLlwiLCBcIlJlYWQgbW9yZSBhbmQgbGVhcm4gaG93IHRvIGZpeCBpdCBoZXJlOiBodHRwczovL2RvY3MudXBsb2FkdGhpbmcuY29tL2ZhcSNteS1jYWxsYmFjay1ydW5zLWluLWRldmVsb3BtZW50LWJ1dC1ub3QtaW4tcHJvZHVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrVXJsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZU1heWJlVXJsQXJnKHBhcnNlZEZyb21IZWFkZXJzKTtcbn1cbmNvbnN0IGJ1aWxkUGVybWlzc2lvbnNJbmZvSGFuZGxlciA9IChvcHRzKT0+e1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBjb25zdCByID0gb3B0cy5yb3V0ZXI7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gT2JqZWN0LmtleXMocikubWFwKChrKT0+e1xuICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByW2tdO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gZmlsbElucHV0Um91dGVDb25maWcocm91dGUuX2RlZi5yb3V0ZXJDb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzbHVnOiBrLFxuICAgICAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwZXJtaXNzaW9ucztcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gaW5jb21wYXRpYmxlTm9kZUd1YXJkKCkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGxldCBtYWpvcjtcbiAgICBsZXQgbWlub3I7XG4gICAgY29uc3QgbWF5YmVOb2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnM/Lm5vZGU/LnNwbGl0KFwiLlwiKTtcbiAgICBpZiAobWF5YmVOb2RlVmVyc2lvbikge1xuICAgICAgICBbbWFqb3IsIG1pbm9yXSA9IG1heWJlTm9kZVZlcnNpb24ubWFwKCh2KT0+cGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gICAgY29uc3QgbWF5YmVOb2RlUGF0aCA9IHByb2Nlc3MuZW52Py5OT0RFO1xuICAgIGlmICghbWFqb3IgJiYgbWF5YmVOb2RlUGF0aCkge1xuICAgICAgICBjb25zdCBub2RlVmVyc2lvbiA9IC92KFxcZCspXFwuKFxcZCspXFwuKFxcZCspLy5leGVjKG1heWJlTm9kZVBhdGgpPy5bMF07XG4gICAgICAgIGlmIChub2RlVmVyc2lvbikge1xuICAgICAgICAgICAgW21ham9yLCBtaW5vcl0gPSBub2RlVmVyc2lvbi5zdWJzdHJpbmcoMSkuc3BsaXQoXCIuXCIpLm1hcCgodik9PnBhcnNlSW50KHYsIDEwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtYWpvciB8fCAhbWlub3IpIHJldHVybjtcbiAgICAvLyBSZXF1aXJlIF4xOC4xMy4wXG4gICAgaWYgKG1ham9yID4gMTgpIHJldHVybjtcbiAgICBpZiAobWFqb3IgPT09IDE4ICYmIG1pbm9yID49IDEzKSByZXR1cm47XG4gICAgbG9nZ2VyLmZhdGFsKGBZT1UgQVJFIFVTSU5HIEEgTEVHQUNZICgke21ham9yfS4ke21pbm9yfSkgTk9ERSBWRVJTSU9OIFdISUNIIElTTidUIE9GRklDSUFMTFkgU1VQUE9SVEVELiBQTEVBU0UgVVBHUkFERSBUTyBOT0RFIF4xOC4xMy5gKTtcbiAgICAvLyBLaWxsIHRoZSBwcm9jZXNzIGlmIGl0IGlzbid0IGdvaW5nIHRvIHdvcmsgY29ycmVjdGx5IGFueXdheVxuICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiB0aGlzIGZhciB3ZSBrbm93IHdlIGhhdmUgYSBOb2RlLmpzIHJ1bnRpbWUgc28gZXhpdCBpcyBkZWZpbmVkLiBPdmVycmlkZSBzdGQtZW52IHR5cGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgcHJvY2Vzcy5leGl0Py4oMSk7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsQ3JlYXRlQnVpbGRlcihpbml0RGVmID0ge30pIHtcbiAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICAvLyBEZWZhdWx0IHJvdXRlciBjb25maWdcbiAgICAgICAgcm91dGVyQ29uZmlnOiB7XG4gICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiBcIjRNQlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0UGFyc2VyOiB7XG4gICAgICAgICAgICBwYXJzZTogKCk9PnVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9pbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX291dHB1dDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZXdhcmU6ICgpPT4oe30pLFxuICAgICAgICBvblVwbG9hZEVycm9yOiAoKT0+KHt9KSxcbiAgICAgICAgZXJyb3JGb3JtYXR0ZXI6IGluaXREZWYuZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEVycm9yRm9ybWF0dGVyLFxuICAgICAgICAvLyBPdmVybG9hZCB3aXRoIHByb3BlcnRpZXMgcGFzc2VkIGluXG4gICAgICAgIC4uLmluaXREZWZcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0ICh1c2VyUGFyc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5fZGVmLFxuICAgICAgICAgICAgICAgIGlucHV0UGFyc2VyOiB1c2VyUGFyc2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxld2FyZSAodXNlck1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZTogdXNlck1pZGRsZXdhcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZENvbXBsZXRlICh1c2VyVXBsb2FkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2RlZixcbiAgICAgICAgICAgICAgICByZXNvbHZlcjogdXNlclVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZEVycm9yICh1c2VyT25VcGxvYWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBvblVwbG9hZEVycm9yOiB1c2VyT25VcGxvYWRFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQnVpbGRlcihvcHRzKSB7XG4gICAgcmV0dXJuIChpbnB1dCk9PntcbiAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICByb3V0ZXJDb25maWc6IGlucHV0LFxuICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5jb25zdCBtYXliZVBhcnNlUmVzcG9uc2VYTUwgPSAobWF5YmVYbWwpPT57XG4gICAgY29uc3QgY29kZU1hdGNoID0gbWF5YmVYbWwubWF0Y2goLzxDb2RlPiguKj8pPFxcL0NvZGU+L3MpO1xuICAgIGNvbnN0IG1lc3NhZ2VNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88TWVzc2FnZT4oLio/KTxcXC9NZXNzYWdlPi9zKTtcbiAgICBjb25zdCBjb2RlID0gY29kZU1hdGNoPy5bMV07XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VNYXRjaD8uWzFdO1xuICAgIGlmICghY29kZSB8fCAhbWVzc2FnZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogczNDb2RlVG9VcGxvYWRUaGluZ0NvZGVbY29kZV0gPz8gREVGQVVMVF9FUlJPUl9DT0RFLFxuICAgICAgICBtZXNzYWdlXG4gICAgfTtcbn07XG4vKipcbiAqIE1hcCBTMyBlcnJvciBjb2RlcyB0byBVcGxvYWRUaGluZyBlcnJvciBjb2Rlc1xuICpcbiAqIFRoaXMgaXMgYSBzdWJzZXQgb2YgdGhlIFMzIGVycm9yIGNvZGVzLCBiYXNlZCBvbiB3aGF0IHNlZW1lZCBtb3N0IGxpa2VseSB0b1xuICogb2NjdXIgaW4gdXBsb2FkdGhpbmcuIEZvciBhIGZ1bGwgbGlzdCBvZiBTMyBlcnJvciBjb2Rlcywgc2VlOlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC9BUEkvRXJyb3JSZXNwb25zZXMuaHRtbFxuICovIGNvbnN0IERFRkFVTFRfRVJST1JfQ09ERSA9IFwiVVBMT0FEX0ZBSUxFRFwiO1xuY29uc3QgczNDb2RlVG9VcGxvYWRUaGluZ0NvZGUgPSB7XG4gICAgQWNjZXNzRGVuaWVkOiBcIkZPUkJJRERFTlwiLFxuICAgIEVudGl0eVRvb1NtYWxsOiBcIlRPT19TTUFMTFwiLFxuICAgIEVudGl0eVRvb0xhcmdlOiBcIlRPT19MQVJHRVwiLFxuICAgIEV4cGlyZWRUb2tlbjogXCJGT1JCSURERU5cIixcbiAgICBJbmNvcnJlY3ROdW1iZXJPZkZpbGVzSW5Qb3N0UmVxdWVzdDogXCJUT09fTUFOWV9GSUxFU1wiLFxuICAgIEludGVybmFsRXJyb3I6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgS2V5VG9vTG9uZ0Vycm9yOiBcIktFWV9UT09fTE9OR1wiLFxuICAgIE1heE1lc3NhZ2VMZW5ndGhFeGNlZWRlZDogXCJUT09fTEFSR0VcIlxufTtcblxuLyoqXG4gKiBVc2VkIGJ5IHNlcnZlciB1cGxvYWRzIHdoZXJlIHByb2dyZXNzIGlzIG5vdCBuZWVkZWQuXG4gKiBVc2VzIG5vcm1hbCBmZXRjaCBBUEkuXG4gKi8gYXN5bmMgZnVuY3Rpb24gdXBsb2FkUGFydChvcHRzLCByZXRyeUNvdW50ID0gMCkge1xuICAgIGNvbnN0IHMzUmVzID0gYXdhaXQgb3B0cy5mZXRjaChvcHRzLnVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGJvZHk6IG9wdHMuY2h1bmssXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IG9wdHMuY29udGVudFR5cGUsXG4gICAgICAgICAgICBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIjogY29udGVudERpc3Bvc2l0aW9uKG9wdHMuY29udGVudERpc3Bvc2l0aW9uLCBvcHRzLmZpbGVOYW1lKVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHMzUmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGV0YWcgPSBzM1Jlcy5oZWFkZXJzLmdldChcIkV0YWdcIik7XG4gICAgICAgIGlmICghZXRhZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBFdGFnIGhlYWRlciBmcm9tIHVwbG9hZGVkIHBhcnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV0YWcucmVwbGFjZSgvXCIvZywgXCJcIik7XG4gICAgfVxuICAgIGlmIChyZXRyeUNvdW50IDwgb3B0cy5tYXhSZXRyaWVzKSB7XG4gICAgICAgIC8vIFJldHJ5IGFmdGVyIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyICoqIHJldHJ5Q291bnQgKiAxMDAwO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocik9PnNldFRpbWVvdXQociwgZGVsYXkpKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZFBhcnQob3B0cywgcmV0cnlDb3VudCsrKTtcbiAgICB9XG4gICAgLy8gTWF4IHJldHJpZXMgZXhjZWVkZWQsIHRlbGwgVVQgc2VydmVyIHRoYXQgdXBsb2FkIGZhaWxlZFxuICAgIGF3YWl0IG9wdHMuZmV0Y2goZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChcIi9hcGkvZmFpbHVyZUNhbGxiYWNrXCIpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGZpbGVLZXk6IG9wdHMua2V5XG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLnV0UmVxdWVzdEhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgczNSZXMudGV4dCgpO1xuICAgIGNvbnN0IHBhcnNlZCA9IG1heWJlUGFyc2VSZXNwb25zZVhNTCh0ZXh0KTtcbiAgICBpZiAocGFyc2VkPy5tZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFyc2VkLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHVwbG9hZCBmaWxlIHRvIHN0b3JhZ2UgcHJvdmlkZXJcIixcbiAgICAgICAgY2F1c2U6IHMzUmVzXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGd1YXJkU2VydmVyT25seSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJUaGUgYHV0YXBpYCBjYW4gb25seSBiZSB1c2VkIG9uIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QXBpS2V5T3JUaHJvdyhhcGlLZXkpIHtcbiAgICBpZiAoYXBpS2V5KSByZXR1cm4gYXBpS2V5O1xuICAgIGlmIChwcm9jZXNzLmVudi5VUExPQURUSElOR19TRUNSRVQpIHJldHVybiBwcm9jZXNzLmVudi5VUExPQURUSElOR19TRUNSRVQ7XG4gICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIk1JU1NJTkdfRU5WXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBgVVBMT0FEVEhJTkdfU0VDUkVUYCBlbnYgdmFyaWFibGUuXCJcbiAgICB9KTtcbn1cbmNvbnN0IHVwbG9hZEZpbGVzSW50ZXJuYWwgPSBhc3luYyAoZGF0YSwgb3B0cyk9PntcbiAgICAvLyBSZXF1ZXN0IHByZXNpZ25lZCBVUkxzIGZvciBlYWNoIGZpbGVcbiAgICBjb25zdCBmaWxlRGF0YSA9IGRhdGEuZmlsZXMubWFwKChmaWxlKT0+KHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSA/PyBcInVubmFtZWQtYmxvYlwiLFxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgLi4uXCJjdXN0b21JZFwiIGluIGZpbGUgPyB7XG4gICAgICAgICAgICAgICAgY3VzdG9tSWQ6IGZpbGUuY3VzdG9tSWRcbiAgICAgICAgICAgIH0gOiB7fVxuICAgICAgICB9KSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBwcmVzaWduZWQgVVJMcyBmb3IgZmlsZXNcIiwgZmlsZURhdGEpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9wdHMuZmV0Y2goZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChcIi9hcGkvdXBsb2FkRmlsZXNcIiksIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczogb3B0cy51dFJlcXVlc3RIZWFkZXJzLFxuICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBmaWxlczogZmlsZURhdGEsXG4gICAgICAgICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogZGF0YS5jb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgICAgICBhY2w6IGRhdGEuYWNsXG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCBVcGxvYWRUaGluZ0Vycm9yLmZyb21SZXNwb25zZShyZXMpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJGYWlsZWQgZ2V0dGluZyBwcmVzaWduZWQgVVJMczpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiR290IHByZXNpZ25lZCBVUkxzOlwiLCBqc29uLmRhdGEpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIHVwbG9hZHMuLi5cIik7XG4gICAgLy8gVXBsb2FkIGVhY2ggZmlsZSB0byBTMyBpbiBjaHVua3MgdXNpbmcgbXVsdGktcGFydCB1cGxvYWRzXG4gICAgY29uc3QgdXBsb2FkcyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChkYXRhLmZpbGVzLm1hcChhc3luYyAoZmlsZSwgaSk9PntcbiAgICAgICAgY29uc3QgcHJlc2lnbmVkID0ganNvbi5kYXRhW2ldO1xuICAgICAgICBpZiAoIXByZXNpZ25lZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIHByZXNpZ25lZCBVUkwgZm9yIGZpbGU6XCIsIGZpbGUsIHByZXNpZ25lZCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJVUkxfR0VORVJBVElPTl9GQUlMRURcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBnZW5lcmF0ZSBwcmVzaWduZWQgVVJMXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IEpTT04uc3RyaW5naWZ5KHByZXNpZ25lZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInVybHNcIiBpbiBwcmVzaWduZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZE11bHRpcGFydChmaWxlLCBwcmVzaWduZWQsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZFByZXNpZ25lZFBvc3QoZmlsZSwgcHJlc2lnbmVkLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9sbCBmb3IgZmlsZSB0byBiZSBhdmFpbGFibGVcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUG9sbGluZyBmb3IgZmlsZSBkYXRhLi4uXCIpO1xuICAgICAgICBhd2FpdCBwb2xsRm9yRmlsZURhdGEoe1xuICAgICAgICAgICAgdXJsOiBnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKGAvYXBpL3BvbGxVcGxvYWQvJHtwcmVzaWduZWQua2V5fWApLFxuICAgICAgICAgICAgYXBpS2V5OiBvcHRzLnV0UmVxdWVzdEhlYWRlcnNbXCJ4LXVwbG9hZHRoaW5nLWFwaS1rZXlcIl0sXG4gICAgICAgICAgICBzZGtWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgZmV0Y2g6IG9wdHMuZmV0Y2hcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBvbGxpbmcgY29tcGxldGUuXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgdXJsOiBwcmVzaWduZWQuZmlsZVVybCxcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIGN1c3RvbUlkOiBcImN1c3RvbUlkXCIgaW4gZmlsZSA/IGZpbGUuY3VzdG9tSWQgPz8gbnVsbCA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9KSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQWxsIHVwbG9hZHMgY29tcGxldGUsIGFnZ3JlZ2F0aW5nIHJlc3VsdHMuLi5cIik7XG4gICAgcmV0dXJuIHVwbG9hZHMubWFwKCh1cGxvYWQpPT57XG4gICAgICAgIGlmICh1cGxvYWQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdXBsb2FkLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG9ubHkgdGhyb3cgVXBsb2FkVGhpbmdFcnJvcnMsIHNvIHRoaXMgaXMgc2FmZVxuICAgICAgICBjb25zdCByZWFzb24gPSB1cGxvYWQucmVhc29uO1xuICAgICAgICBjb25zdCBlcnJvciA9IFVwbG9hZFRoaW5nRXJyb3IudG9PYmplY3QocmVhc29uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICB9O1xuICAgIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZE11bHRpcGFydChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRpbmcgZmlsZVwiLCBmaWxlLm5hbWUsIFwid2l0aFwiLCBwcmVzaWduZWQudXJscy5sZW5ndGgsIFwiY2h1bmtzIG9mIHNpemVcIiwgcHJlc2lnbmVkLmNodW5rU2l6ZSwgXCJieXRlcyBlYWNoXCIpO1xuICAgIGNvbnN0IGV0YWdzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJlc2lnbmVkLnVybHMubWFwKGFzeW5jICh1cmwsIGluZGV4KT0+e1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBwcmVzaWduZWQuY2h1bmtTaXplICogaW5kZXg7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG9mZnNldCArIHByZXNpZ25lZC5jaHVua1NpemUsIGZpbGUuc2l6ZSk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIGVuZCk7XG4gICAgICAgIGNvbnN0IGV0YWcgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICAgIGZldGNoOiBvcHRzLmZldGNoLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBwcmVzaWduZWQuY29udGVudERpc3Bvc2l0aW9uLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBtYXhSZXRyaWVzOiAxMCxcbiAgICAgICAgICAgIGtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHV0UmVxdWVzdEhlYWRlcnM6IG9wdHMudXRSZXF1ZXN0SGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUGFydFwiLCBpbmRleCArIDEsIFwidXBsb2FkZWQgc3VjY2Vzc2Z1bGx5OlwiLCBldGFnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhZzogZXRhZyxcbiAgICAgICAgICAgIHBhcnROdW1iZXI6IGluZGV4ICsgMVxuICAgICAgICB9O1xuICAgIH0pKTtcbiAgICBsb2dnZXIuZGVidWcoXCJGaWxlXCIsIGZpbGUubmFtZSwgXCJ1cGxvYWRlZCBzdWNjZXNzZnVsbHkuIE5vdGlmeWluZyBVcGxvYWRUaGluZyB0byBjb21wbGV0ZSBtdWx0aXBhcnQgdXBsb2FkLlwiKTtcbiAgICAvLyBDb21wbGV0ZSBtdWx0aXBhcnQgdXBsb2FkXG4gICAgY29uc3QgY29tcGxldGlvblJlcyA9IGF3YWl0IG9wdHMuZmV0Y2goZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChcIi9hcGkvY29tcGxldGVNdWx0aXBhcnRcIiksIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgICAgICBldGFnc1xuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczogb3B0cy51dFJlcXVlc3RIZWFkZXJzXG4gICAgfSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uc2VkIHdpdGggc3RhdHVzOlwiLCBjb21wbGV0aW9uUmVzLnN0YXR1cyk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRQcmVzaWduZWRQb3N0KGZpbGUsIHByZXNpZ25lZCwgb3B0cykge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZGluZyBmaWxlXCIsIGZpbGUubmFtZSwgXCJ1c2luZyBwcmVzaWduZWQgUE9TVCBVUkxcIik7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBPYmplY3QuZW50cmllcyhwcmVzaWduZWQuZmllbGRzKS5mb3JFYWNoKChbaywgdl0pPT5mb3JtRGF0YS5hcHBlbmQoaywgdikpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSk7IC8vIEZpbGUgZGF0YSAqKk1VU1QgR08gTEFTVCoqXG4gICAgY29uc3QgcmVzID0gYXdhaXQgb3B0cy5mZXRjaChwcmVzaWduZWQudXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24veG1sXCJcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHVwbG9hZCBmaWxlOlwiLCB0ZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byB1cGxvYWQgZmlsZVwiLFxuICAgICAgICAgICAgY2F1c2U6IHRleHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVcIiwgZmlsZS5uYW1lLCBcInVwbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZVRvU2Vjb25kcyh0aW1lKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aW1lLnRvU3RyaW5nKCkuc3BsaXQoLyhcXGQrKS8pLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBudW0gPSBOdW1iZXIobWF0Y2hbMF0pO1xuICAgIGNvbnN0IHVuaXQgPSAobWF0Y2hbMV0gPz8gXCJzXCIpLnRyaW0oKS5zbGljZSgwLCAxKTtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0ge1xuICAgICAgICBzOiAxLFxuICAgICAgICBtOiA2MCxcbiAgICAgICAgaDogMzYwMCxcbiAgICAgICAgZDogODY0MDBcbiAgICB9W3VuaXRdO1xuICAgIHJldHVybiBudW0gKiBtdWx0aXBsaWVyO1xufVxuXG4vKipcbiAqIEV4dGVuc2lvbiBvZiB0aGUgQmxvYiBjbGFzcyB0aGF0IHNpbXBsaWZpZXMgc2V0dGluZyB0aGUgYG5hbWVgIGFuZCBgY3VzdG9tSWRgIHByb3BlcnRpZXMsXG4gKiBzaW1pbGFyIHRvIHRoZSBidWlsdC1pbiBGaWxlIGNsYXNzIGZyb20gTm9kZSA+IDIwLlxuICovIGNsYXNzIFVURmlsZSBleHRlbmRzIEJsb2Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcnRzLCBuYW1lLCBvcHRpb25zKXtcbiAgICAgICAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB0eXBlOiBvcHRpb25zPy50eXBlID8/IChsb29rdXAobmFtZSkgfHwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZDogb3B0aW9ucz8ubGFzdE1vZGlmaWVkID8/IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIocGFydHMsIG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmN1c3RvbUlkID0gb3B0aW9uc1dpdGhEZWZhdWx0cy5jdXN0b21JZDtcbiAgICAgICAgdGhpcy5sYXN0TW9kaWZpZWQgPSBvcHRpb25zV2l0aERlZmF1bHRzLmxhc3RNb2RpZmllZDtcbiAgICB9XG59XG5jbGFzcyBVVEFwaSB7XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGRlbGV0ZSBmaWxlcyBmcm9tIFVwbG9hZFRoaW5nIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGZpbGVLZXlzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGRlbGV0ZUZpbGVzKFwiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZGVsZXRlRmlsZXMoW1wiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiLFwiMTY0OTM1M2ItMDRlYS00OGEyLTlkYjctMzFkZTdmNTYyYzhkX2ltYWdlMi5qcGdcIl0pXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IGRlbGV0ZUZpbGVzKFwibXlDdXN0b21JZGVudGlmaWVyXCIsIHsga2V5VHlwZTogXCJjdXN0b21JZFwiIH0pXG4gICAqLyB0aGlzLmRlbGV0ZUZpbGVzID0gYXN5bmMgKGtleXMsIG9wdHMpPT57XG4gICAgICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5VHlwZSA9IHRoaXMuZGVmYXVsdEtleVR5cGUgfSA9IG9wdHMgPz8ge307XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VXBsb2FkVGhpbmcoXCIvYXBpL2RlbGV0ZUZpbGVcIiwga2V5VHlwZSA9PT0gXCJmaWxlS2V5XCIgPyB7XG4gICAgICAgICAgICAgICAgZmlsZUtleXM6IGFzQXJyYXkoa2V5cylcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgY3VzdG9tSWRzOiBhc0FycmF5KGtleXMpXG4gICAgICAgICAgICB9LCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZGVsZXRpbmcgZmlsZXMuXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICogUmVxdWVzdCBmaWxlIFVSTHMgZnJvbSBVcGxvYWRUaGluZyBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBmaWxlS2V5c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkYXRhID0gYXdhaXQgZ2V0RmlsZVVybHMoXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIpO1xuICAgKiBjb25zb2xlLmxvZyhkYXRhKTsgLy8gW3trZXk6IFwiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiLCB1cmw6IFwiaHR0cHM6Ly91cGxvYWR0aGluZy5jb20vZi8yZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCJ9XVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkYXRhID0gYXdhaXQgZ2V0RmlsZVVybHMoW1wiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiLFwiMTY0OTM1M2ItMDRlYS00OGEyLTlkYjctMzFkZTdmNTYyYzhkX2ltYWdlMi5qcGdcIl0pXG4gICAqIGNvbnNvbGUubG9nKGRhdGEpIC8vIFt7a2V5OiBcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIiwgdXJsOiBcImh0dHBzOi8vdXBsb2FkdGhpbmcuY29tL2YvMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiIH0se2tleTogXCIxNjQ5MzUzYi0wNGVhLTQ4YTItOWRiNy0zMWRlN2Y1NjJjOGRfaW1hZ2UyLmpwZ1wiLCB1cmw6IFwiaHR0cHM6Ly91cGxvYWR0aGluZy5jb20vZi8xNjQ5MzUzYi0wNGVhLTQ4YTItOWRiNy0zMWRlN2Y1NjJjOGRfaW1hZ2UyLmpwZ1wifV1cbiAgICovIHRoaXMuZ2V0RmlsZVVybHMgPSBhc3luYyAoa2V5cywgb3B0cyk9PntcbiAgICAgICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICAgICAgY29uc3QgeyBrZXlUeXBlID0gdGhpcy5kZWZhdWx0S2V5VHlwZSB9ID0gb3B0cyA/PyB7fTtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCB0aGlzLnJlcXVlc3RVcGxvYWRUaGluZyhcIi9hcGkvZ2V0RmlsZVVybFwiLCBrZXlUeXBlID09PSBcImZpbGVLZXlcIiA/IHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5czogYXNBcnJheShrZXlzKVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBjdXN0b21JZHM6IGFzQXJyYXkoa2V5cylcbiAgICAgICAgICAgIH0sIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXRyaWV2aW5nIGZpbGUgVVJMcy5cIik7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICogUmVxdWVzdCBmaWxlIGxpc3QgZnJvbSBVcGxvYWRUaGluZyBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5saW1pdCBUaGUgbWF4aW11bSBudW1iZXIgb2YgZmlsZXMgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLm9mZnNldCBUaGUgbnVtYmVyIG9mIGZpbGVzIHRvIHNraXBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZGF0YSA9IGF3YWl0IGxpc3RGaWxlcyh7IGxpbWl0OiAxIH0pO1xuICAgKiBjb25zb2xlLmxvZyhkYXRhKTsgLy8geyBrZXk6IFwiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiLCBpZDogXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhcIiB9XG4gICAqLyB0aGlzLmxpc3RGaWxlcyA9IGFzeW5jIChvcHRzKT0+e1xuICAgICAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgdGhpcy5yZXF1ZXN0VXBsb2FkVGhpbmcoXCIvYXBpL2xpc3RGaWxlc1wiLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICAgICAgfSwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGxpc3RpbmcgZmlsZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uZmlsZXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuYW1lRmlsZXMgPSBhc3luYyAodXBkYXRlcyk9PntcbiAgICAgICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFVwbG9hZFRoaW5nKFwiL2FwaS9yZW5hbWVGaWxlc1wiLCB7XG4gICAgICAgICAgICAgICAgdXBkYXRlczogYXNBcnJheSh1cGRhdGVzKVxuICAgICAgICAgICAgfSwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlbmFtaW5nIGZpbGVzLlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgcmVuYW1lRmlsZXN9IGluc3RlYWQuICovIHRoaXMucmVuYW1lRmlsZSA9IHRoaXMucmVuYW1lRmlsZXM7XG4gICAgICAgIHRoaXMuZ2V0VXNhZ2VJbmZvID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFVwbG9hZFRoaW5nKFwiL2FwaS9nZXRVc2FnZUluZm9cIiwge30sIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBnZXR0aW5nIHVzYWdlIGluZm8uXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogUmVxdWVzdCBhIHByZXNpZ25lZCB1cmwgZm9yIGEgcHJpdmF0ZSBmaWxlKHMpICovIHRoaXMuZ2V0U2lnbmVkVVJMID0gYXN5bmMgKGtleSwgb3B0cyk9PntcbiAgICAgICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gb3B0cz8uZXhwaXJlc0luID8gcGFyc2VUaW1lVG9TZWNvbmRzKG9wdHMuZXhwaXJlc0luKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5VHlwZSA9IHRoaXMuZGVmYXVsdEtleVR5cGUgfSA9IG9wdHMgPz8ge307XG4gICAgICAgICAgICBpZiAob3B0cz8uZXhwaXJlc0luICYmIGlzTmFOKGV4cGlyZXNJbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJleHBpcmVzSW4gbXVzdCBiZSBhIHZhbGlkIHRpbWUgc3RyaW5nLCBmb3IgZXhhbXBsZSAnMWQnLCAnMiBkYXlzJywgb3IgYSBudW1iZXIgb2Ygc2Vjb25kcy5cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cGlyZXNJbiAmJiBleHBpcmVzSW4gPiA4NjQwMCAqIDcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJleHBpcmVzSW4gbXVzdCBiZSBsZXNzIHRoYW4gNyBkYXlzICg2MDQ4MDAgc2Vjb25kcykuXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCB0aGlzLnJlcXVlc3RVcGxvYWRUaGluZyhcIi9hcGkvcmVxdWVzdEZpbGVBY2Nlc3NcIiwga2V5VHlwZSA9PT0gXCJmaWxlS2V5XCIgPyB7XG4gICAgICAgICAgICAgICAgZmlsZUtleToga2V5LFxuICAgICAgICAgICAgICAgIGV4cGlyZXNJblxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBjdXN0b21JZDoga2V5LFxuICAgICAgICAgICAgICAgIGV4cGlyZXNJblxuICAgICAgICAgICAgfSwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgcHJlc2lnbmVkIFVSTHMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb24udXJsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZldGNoID0gb3B0cz8uZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRzPy5hcGlLZXkgPz8gcHJvY2Vzcy5lbnYuVVBMT0FEVEhJTkdfU0VDUkVUO1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctYXBpLWtleVwiOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24sXG4gICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctYmUtYWRhcHRlclwiOiBcInNlcnZlci1zZGtcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRLZXlUeXBlID0gb3B0cz8uZGVmYXVsdEtleVR5cGUgPz8gXCJmaWxlS2V5XCI7XG4gICAgICAgIGluaXRMb2dnZXIob3B0cz8ubG9nTGV2ZWwpO1xuICAgICAgICAvLyBBc3NlcnQgc29tZSBzdHVmZlxuICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgZ2V0QXBpS2V5T3JUaHJvdyh0aGlzLmFwaUtleSk7XG4gICAgICAgIGlmICghdGhpcy5hcGlLZXk/LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIk1JU1NJTkdfRU5WXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEFQSSBrZXkuIEFQSSBrZXlzIG11c3Qgc3RhcnQgd2l0aCBgc2tfYC5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5jb21wYXRpYmxlTm9kZUd1YXJkKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RVcGxvYWRUaGluZyhwYXRobmFtZSwgYm9keSwgZmFsbGJhY2tFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdXJsID0gZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTChwYXRobmFtZSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJlcXVlc3RpbmcgVXBsb2FkVGhpbmc6XCIsIHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmRlZmF1bHRIZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbnNlZCB3aXRoIHN0YXR1czpcIiwgcmVzLnN0YXR1cyk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBpZiAoIXJlcy5vayB8fCBcImVycm9yXCIgaW4ganNvbikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3I6XCIsIGpzb24pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJlcnJvclwiIGluIGpzb24gJiYgdHlwZW9mIGpzb24uZXJyb3IgPT09IFwic3RyaW5nXCIgPyBqc29uLmVycm9yIDogZmFsbGJhY2tFcnJvck1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbnNlOlwiLCBqc29uKTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVzKGZpbGVzLCBvcHRzKSB7XG4gICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICBjb25zdCB1cGxvYWRzID0gYXdhaXQgdXBsb2FkRmlsZXNJbnRlcm5hbCh7XG4gICAgICAgICAgICBmaWxlczogYXNBcnJheShmaWxlcyksXG4gICAgICAgICAgICBtZXRhZGF0YTogb3B0cz8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IG9wdHM/LmNvbnRlbnREaXNwb3NpdGlvbiA/PyBcImlubGluZVwiLFxuICAgICAgICAgICAgYWNsOiBvcHRzPy5hY2xcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICB1dFJlcXVlc3RIZWFkZXJzOiB0aGlzLmRlZmF1bHRIZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cGxvYWRGaWxlUmVzcG9uc2UgPSBBcnJheS5pc0FycmF5KGZpbGVzKSA/IHVwbG9hZHMgOiB1cGxvYWRzWzBdO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJGaW5pc2hlZCB1cGxvYWRpbmc6XCIsIHVwbG9hZEZpbGVSZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB1cGxvYWRGaWxlUmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVzRnJvbVVybCh1cmxzLCBvcHRzKSB7XG4gICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBKU09OLnN0cmluZ2lmeShvcHRzPy5tZXRhZGF0YSA/PyB7fSkpO1xuICAgICAgICBjb25zdCBkb3dubG9hZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKGFzQXJyYXkodXJscykubWFwKGFzeW5jIChfdXJsLCBpbmRleCk9PntcbiAgICAgICAgICAgIGxldCB1cmwgPSBpc09iamVjdChfdXJsKSA/IF91cmwudXJsIDogX3VybDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZGF0YXVybHMgd2lsbCByZXN1bHQgaW4gbmFtZSBiZWluZyB0b28gbG9uZywgdGVsbCB0aGUgdXNlclxuICAgICAgICAgICAgICAgIC8vIHRvIHVzZSB1cGxvYWRGaWxlcyBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkRXJyb3JzW2luZGV4XSA9IFVwbG9hZFRoaW5nRXJyb3IudG9PYmplY3QobmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJQbGVhc2UgdXNlIHVwbG9hZEZpbGVzKCkgZm9yIGRhdGEgVVJMcy4gdXBsb2FkRmlsZXNGcm9tVXJsKCkgaXMgaW50ZW5kZWQgZm9yIHVzZSB3aXRoIHJlbW90ZSBVUkxzIG9ubHkuXCJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgPSB1cmwucGF0aG5hbWUuc3BsaXQoXCIvXCIpLnBvcCgpID8/IFwidW5rbm93bi1maWxlbmFtZVwiLCBjdXN0b21JZCA9IHVuZGVmaW5lZCB9ID0gaXNPYmplY3QoX3VybCkgPyBfdXJsIDoge307XG4gICAgICAgICAgICAvLyBEb3dubG9hZCB0aGUgZmlsZSBvbiB0aGUgdXNlcidzIHNlcnZlciB0byBhdm9pZCBlZ3Jlc3MgY2hhcmdlc1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRG93bmxvYWRpbmcgZmlsZTpcIiwgdXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVSZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGlmICghZmlsZVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRFcnJvcnNbaW5kZXhdID0gVXBsb2FkVGhpbmdFcnJvci50b09iamVjdChuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gZG93bmxvYWQgcmVxdWVzdGVkIGZpbGUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBmaWxlUmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbmlzaGVkIGRvd25sb2FkaW5nIGZpbGUuIFJlYWRpbmcgYmxvYi4uLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBmaWxlUmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmluaXNoZWQgcmVhZGluZyBibG9iLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVRGaWxlKFtcbiAgICAgICAgICAgICAgICBibG9iXG4gICAgICAgICAgICBdLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgY3VzdG9tSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSkudGhlbigoZmlsZXMpPT5maWxlcy5maWx0ZXIoKHgpPT54ICE9PSB1bmRlZmluZWQpKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkaW5nIGZpbGVzOlwiLCBmaWxlcyk7XG4gICAgICAgIGNvbnN0IHVwbG9hZHMgPSBhd2FpdCB1cGxvYWRGaWxlc0ludGVybmFsKHtcbiAgICAgICAgICAgIGZpbGVzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG9wdHM/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBvcHRzPy5jb250ZW50RGlzcG9zaXRpb24gPz8gXCJpbmxpbmVcIixcbiAgICAgICAgICAgIGFjbDogb3B0cz8uYWNsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgdXRSZXF1ZXN0SGVhZGVyczogdGhpcy5kZWZhdWx0SGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFB1dCBpdCBhbGwgYmFjayB0b2dldGhlciwgcHJlc2VydmUgdGhlIG9yZGVyIG9mIGZpbGVzICovIGNvbnN0IHJlc3BvbnNlcyA9IGFzQXJyYXkodXJscykubWFwKChfLCBpbmRleCk9PntcbiAgICAgICAgICAgIGlmIChkb3dubG9hZEVycm9yc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZG93bmxvYWRFcnJvcnNbaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRzLnNoaWZ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKiogUmV0dXJuIHNpbmdsZSBvYmplY3Qgb3IgYXJyYXkgYmFzZWQgb24gaW5wdXQgdXJscyAqLyBjb25zdCB1cGxvYWRGaWxlUmVzcG9uc2UgPSBBcnJheS5pc0FycmF5KHVybHMpID8gcmVzcG9uc2VzIDogcmVzcG9uc2VzWzBdO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJGaW5pc2hlZCB1cGxvYWRpbmc6XCIsIHVwbG9hZEZpbGVSZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB1cGxvYWRGaWxlUmVzcG9uc2U7XG4gICAgfVxufVxuXG5jb25zdCBjcmVhdGVVcGxvYWR0aGluZyA9IChvcHRzKT0+Y3JlYXRlQnVpbGRlcihvcHRzKTtcbi8qKiBAaW50ZXJuYWwgKi8gY29uc3QgSU5URVJOQUxfRE9fTk9UX1VTRV9jcmVhdGVSb3V0ZUhhbmRsZXJDb3JlID0gKG9wdHMsIGFkYXB0ZXIpPT57XG4gICAgaW5pdExvZ2dlcihvcHRzLmNvbmZpZz8ubG9nTGV2ZWwpO1xuICAgIGluY29tcGF0aWJsZU5vZGVHdWFyZCgpO1xuICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gYnVpbGRSZXF1ZXN0SGFuZGxlcihvcHRzLCBhZGFwdGVyKTtcbiAgICBjb25zdCBnZXRCdWlsZFBlcm1zID0gYnVpbGRQZXJtaXNzaW9uc0luZm9IYW5kbGVyKG9wdHMpO1xuICAgIGNvbnN0IFBPU1QgPSBhc3luYyAocmVxdWVzdCk9PntcbiAgICAgICAgY29uc3QgcmVxID0gcmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QgPyByZXF1ZXN0IDogcmVxdWVzdC5yZXF1ZXN0O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RIYW5kbGVyKHtcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcmdzOiB7XG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIHJlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGV2ZW50OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIFVwbG9hZFRoaW5nRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZm9ybWF0RXJyb3IocmVzcG9uc2UsIG9wdHMucm91dGVyKSksIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGdldFN0YXR1c0NvZGVGcm9tRXJyb3IocmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgLy8gV2UgbWVzc2VkIHVwIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZFwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmJvZHkpLCB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdGhpcyBpcyBhIGN1c3RvbSBwcm9wZXJ0eVxuICAgICAgICByZXMuY2xlYW51cCA9IHJlc3BvbnNlLmNsZWFudXA7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBjb25zdCBHRVQgPSAocmVxdWVzdCk9PntcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShnZXRCdWlsZFBlcm1zKCkpLCB7XG4gICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR0VULFxuICAgICAgICBQT1NUXG4gICAgfTtcbn07XG5jb25zdCBjcmVhdGVSb3V0ZUhhbmRsZXIgPSAob3B0cyk9PklOVEVSTkFMX0RPX05PVF9VU0VfY3JlYXRlUm91dGVIYW5kbGVyQ29yZShvcHRzLCBcInNlcnZlclwiKTtcbmNvbnN0IGV4dHJhY3RSb3V0ZXJDb25maWcgPSAocm91dGVyKT0+YnVpbGRQZXJtaXNzaW9uc0luZm9IYW5kbGVyKHtcbiAgICAgICAgcm91dGVyXG4gICAgfSkoKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBjcmVhdGVSb3V0ZUhhbmRsZXJ9IGluc3RlYWRcbiAqLyBjb25zdCBjcmVhdGVTZXJ2ZXJIYW5kbGVyID0gY3JlYXRlUm91dGVIYW5kbGVyO1xuXG5leHBvcnQgeyBJTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUsIFVUQXBpLCBVVEZpbGUsIGNyZWF0ZVJvdXRlSGFuZGxlciwgY3JlYXRlU2VydmVySGFuZGxlciwgY3JlYXRlVXBsb2FkdGhpbmcsIGV4dHJhY3RSb3V0ZXJDb25maWcgfTtcbiJdLCJuYW1lcyI6WyJpc09iamVjdCIsInBvbGxGb3JGaWxlRGF0YSIsImdlbmVyYXRlVXBsb2FkVGhpbmdVUkwiLCJzaWduUGF5bG9hZCIsIlVwbG9hZFRoaW5nRXJyb3IiLCJmaWxsSW5wdXRSb3V0ZUNvbmZpZyIsInNhZmVQYXJzZUpTT04iLCJ2ZXJpZnlTaWduYXR1cmUiLCJyZXNvbHZlTWF5YmVVcmxBcmciLCJnZXRUeXBlRnJvbUZpbGVOYW1lIiwib2JqZWN0S2V5cyIsImNvbnRlbnREaXNwb3NpdGlvbiIsImFzQXJyYXkiLCJnZXRTdGF0dXNDb2RlRnJvbUVycm9yIiwicHJvY2VzcyIsImlzRGV2ZWxvcG1lbnQiLCJjcmVhdGVDb25zb2xhIiwiTG9nTGV2ZWxzIiwiVkFMSURfQUNUSU9OX1RZUEVTIiwiVVRGaWxlcyIsImxvb2t1cCIsInZlcnNpb24iLCJkZWZhdWx0RXJyb3JGb3JtYXR0ZXIiLCJlcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXRFcnJvciIsInJvdXRlciIsImVycm9yRm9ybWF0dGVyIiwiT2JqZWN0Iiwia2V5cyIsIl9kZWYiLCJjb2xvcml6ZSIsInN0ciIsImxldmVsIiwiaWNvbnMiLCJmYXRhbCIsIndhcm4iLCJpbmZvIiwibG9nIiwiZGVidWciLCJ0cmFjZSIsInN1Y2Nlc3MiLCJmb3JtYXRTdGFjayIsInN0YWNrIiwiY3dkIiwic3BsaXQiLCJzcGxpY2UiLCJtYXAiLCJsIiwidHJpbSIsInJlcGxhY2UiLCJqb2luIiwiZm9ybWF0QXJncyIsImFyZ3MiLCJmbXRBcmdzIiwiYXJnIiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZ2dlciIsInJlcG9ydGVycyIsImxvZ09iaiIsInR5cGUiLCJ0YWciLCJkYXRlIiwiaWNvbiIsImxvZ1ByZWZpeCIsInRvTG9jYWxlVGltZVN0cmluZyIsImxpbmVzIiwiY29uc29sZSIsImRlZmF1bHRzIiwiaW5pdExvZ2dlciIsImlzVmFsaWRSZXNwb25zZSIsInJlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJoZWFkZXJzIiwiaGFzIiwiY29uZGl0aW9uYWxEZXZTZXJ2ZXIiLCJvcHRzIiwiZmlsZURhdGEiLCJ1cmwiLCJmaWxlS2V5IiwiYXBpS2V5Iiwic2RrVmVyc2lvbiIsImZldGNoIiwianNvbiIsImZpbGUiLCJjYWxsYmFja1VybCIsImNhbGxiYWNrU2x1ZyIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwibWV0YWRhdGEiLCJwYXJzZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImtleSIsIm5hbWUiLCJmaWxlTmFtZSIsInNpemUiLCJmaWxlU2l6ZSIsImZpbGVUeXBlIiwiY3VzdG9tSWQiLCJzaWduYXR1cmUiLCJtZXRob2QiLCJib2R5IiwiRXJyb3IiLCJlIiwidW5kZWZpbmVkIiwiY29kZSIsImdldFBhcnNlRm4iLCJwYXJzZXIiLCJjcmVhdGVVVEZldGNoIiwiZmVQYWNrYWdlIiwiYmVBZGFwdGVyIiwiZW5kcG9pbnQiLCJmaWxlQ291bnRMaW1pdEhpdCIsImZpbGVzIiwicm91dGVDb25maWciLCJjb3VudHMiLCJmb3JFYWNoIiwiX2tleSIsImNvdW50IiwibGltaXQiLCJtYXhGaWxlQ291bnQiLCJjYXVzZSIsImxpbWl0SGl0IiwiYnVpbGRSZXF1ZXN0SGFuZGxlciIsImFkYXB0ZXIiLCJpbnB1dCIsImlzRGV2IiwiY29uZmlnIiwiZ2xvYmFsVGhpcyIsInByZWZlcnJlZE9yRW52U2VjcmV0IiwidXBsb2FkdGhpbmdTZWNyZXQiLCJlbnYiLCJVUExPQURUSElOR19TRUNSRVQiLCJyZXEiLCJVUkwiLCJwYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJ1cGxvYWR0aGluZ0hvb2siLCJnZXQiLCJzbHVnIiwiYWN0aW9uVHlwZSIsInV0RnJvbnRlbmRQYWNrYWdlIiwiY2xpZW50VmVyc2lvbiIsIm1zZyIsInVwbG9hZGFibGUiLCJ1dEZldGNoIiwibWF5YmVSZXFCb2R5IiwidmVyaWZpZWQiLCJyZXNvbHZlckFyZ3MiLCJyZXMiLCJyZXNvbHZlciIsImNhbGxiYWNrRGF0YSIsImNhbGxiYWNrUmVzcG9uc2UiLCJpbmNsdWRlcyIsIngiLCJtYXliZUlucHV0IiwidXNlcklucHV0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJmIiwicGFyc2VkSW5wdXQiLCJpbnB1dFBhcnNlciIsIm1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlQXJncyIsImxlbmd0aCIsImZpbGVzV2l0aEN1c3RvbUlkcyIsImlkeCIsInRoZWlycyIsInBhcnNlZENvbmZpZyIsInJvdXRlckNvbmZpZyIsInJlc29sdmVDYWxsYmFja1VybCIsImhyZWYiLCJ1cGxvYWR0aGluZ0FwaVJlc3BvbnNlIiwib3JpZ2luIiwicGF0aG5hbWUiLCJwYXJzZWRSZXNwb25zZSIsInByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwiY2F0Y2giLCJjbGVhbnVwIiwiY29tcGxldGVSZXMiLCJ1cGxvYWRJZCIsImV0YWdzIiwib25VcGxvYWRFcnJvciIsIlVQTE9BRFRISU5HX1VSTCIsImhvc3QiLCJwYXJzZWRGcm9tSGVhZGVycyIsImJ1aWxkUGVybWlzc2lvbnNJbmZvSGFuZGxlciIsInIiLCJwZXJtaXNzaW9ucyIsImsiLCJyb3V0ZSIsImluY29tcGF0aWJsZU5vZGVHdWFyZCIsIm1ham9yIiwibWlub3IiLCJtYXliZU5vZGVWZXJzaW9uIiwidmVyc2lvbnMiLCJub2RlIiwidiIsInBhcnNlSW50IiwibWF5YmVOb2RlUGF0aCIsIk5PREUiLCJub2RlVmVyc2lvbiIsImV4ZWMiLCJzdWJzdHJpbmciLCJleGl0IiwiaW50ZXJuYWxDcmVhdGVCdWlsZGVyIiwiaW5pdERlZiIsImltYWdlIiwibWF4RmlsZVNpemUiLCJfaW5wdXQiLCJfb3V0cHV0IiwidXNlclBhcnNlciIsInVzZXJNaWRkbGV3YXJlIiwib25VcGxvYWRDb21wbGV0ZSIsInVzZXJVcGxvYWRDb21wbGV0ZSIsInVzZXJPblVwbG9hZEVycm9yIiwiY3JlYXRlQnVpbGRlciIsIm1heWJlUGFyc2VSZXNwb25zZVhNTCIsIm1heWJlWG1sIiwiY29kZU1hdGNoIiwibWF0Y2giLCJtZXNzYWdlTWF0Y2giLCJzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSIsIkRFRkFVTFRfRVJST1JfQ09ERSIsIkFjY2Vzc0RlbmllZCIsIkVudGl0eVRvb1NtYWxsIiwiRW50aXR5VG9vTGFyZ2UiLCJFeHBpcmVkVG9rZW4iLCJJbmNvcnJlY3ROdW1iZXJPZkZpbGVzSW5Qb3N0UmVxdWVzdCIsIkludGVybmFsRXJyb3IiLCJLZXlUb29Mb25nRXJyb3IiLCJNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQiLCJ1cGxvYWRQYXJ0IiwicmV0cnlDb3VudCIsInMzUmVzIiwiY2h1bmsiLCJjb250ZW50VHlwZSIsImV0YWciLCJtYXhSZXRyaWVzIiwiZGVsYXkiLCJzZXRUaW1lb3V0IiwidXRSZXF1ZXN0SGVhZGVycyIsInRleHQiLCJwYXJzZWQiLCJndWFyZFNlcnZlck9ubHkiLCJnZXRBcGlLZXlPclRocm93IiwidXBsb2FkRmlsZXNJbnRlcm5hbCIsImRhdGEiLCJjYWNoZSIsImFjbCIsImZyb21SZXNwb25zZSIsInVwbG9hZHMiLCJhbGxTZXR0bGVkIiwiaSIsInByZXNpZ25lZCIsInVwbG9hZE11bHRpcGFydCIsInVwbG9hZFByZXNpZ25lZFBvc3QiLCJmaWxlVXJsIiwidXBsb2FkIiwidmFsdWUiLCJyZWFzb24iLCJ0b09iamVjdCIsInVybHMiLCJjaHVua1NpemUiLCJpbmRleCIsIm9mZnNldCIsImVuZCIsIk1hdGgiLCJtaW4iLCJzbGljZSIsInBhcnROdW1iZXIiLCJjb21wbGV0aW9uUmVzIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImVudHJpZXMiLCJmaWVsZHMiLCJhcHBlbmQiLCJIZWFkZXJzIiwiQWNjZXB0IiwicGFyc2VUaW1lVG9TZWNvbmRzIiwidGltZSIsInRvU3RyaW5nIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm51bSIsIk51bWJlciIsInVuaXQiLCJtdWx0aXBsaWVyIiwicyIsIm0iLCJoIiwiZCIsIlVURmlsZSIsIkJsb2IiLCJjb25zdHJ1Y3RvciIsInBhcnRzIiwib3B0aW9ucyIsIm9wdGlvbnNXaXRoRGVmYXVsdHMiLCJsYXN0TW9kaWZpZWQiLCJEYXRlIiwibm93IiwiVVRBcGkiLCJkZWxldGVGaWxlcyIsImtleVR5cGUiLCJkZWZhdWx0S2V5VHlwZSIsInJlcXVlc3RVcGxvYWRUaGluZyIsImZpbGVLZXlzIiwiY3VzdG9tSWRzIiwiZ2V0RmlsZVVybHMiLCJsaXN0RmlsZXMiLCJyZW5hbWVGaWxlcyIsInVwZGF0ZXMiLCJyZW5hbWVGaWxlIiwiZ2V0VXNhZ2VJbmZvIiwiZ2V0U2lnbmVkVVJMIiwiZXhwaXJlc0luIiwiaXNOYU4iLCJkZWZhdWx0SGVhZGVycyIsImxvZ0xldmVsIiwiZmFsbGJhY2tFcnJvck1lc3NhZ2UiLCJ1cGxvYWRGaWxlcyIsInVwbG9hZEZpbGVSZXNwb25zZSIsInVwbG9hZEZpbGVzRnJvbVVybCIsImRvd25sb2FkRXJyb3JzIiwiX3VybCIsInBvcCIsImZpbGVSZXNwb25zZSIsImJsb2IiLCJ0aGVuIiwicmVzcG9uc2VzIiwiXyIsInNoaWZ0IiwiY3JlYXRlVXBsb2FkdGhpbmciLCJJTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUiLCJyZXF1ZXN0SGFuZGxlciIsImdldEJ1aWxkUGVybXMiLCJQT1NUIiwicmVxdWVzdCIsIlJlcXVlc3QiLCJldmVudCIsIlJlc3BvbnNlIiwiR0VUIiwiY3JlYXRlUm91dGVIYW5kbGVyIiwiZXh0cmFjdFJvdXRlckNvbmZpZyIsImNyZWF0ZVNlcnZlckhhbmRsZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uploadthing/server/index.js\n");

/***/ })

};
;